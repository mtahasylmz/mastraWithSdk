"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@upstash";
exports.ids = ["vendor-chunks/@upstash"];
exports.modules = {

/***/ "(rsc)/./node_modules/@upstash/vector/dist/chunk-HESEGT2A.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@upstash/vector/dist/chunk-HESEGT2A.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FusionAlgorithm: () => (/* binding */ FusionAlgorithm),\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient),\n/* harmony export */   Index: () => (/* binding */ Index),\n/* harmony export */   QueryMode: () => (/* binding */ QueryMode),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   WeightingStrategy: () => (/* binding */ WeightingStrategy)\n/* harmony export */ });\n// src/error/index.ts\nvar UpstashError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"UpstashError\";\n  }\n};\n\n// src/http/index.ts\nvar HttpClient = class {\n  baseUrl;\n  headers;\n  options;\n  retry;\n  constructor(config) {\n    this.options = {\n      cache: config.cache,\n      signal: config.signal\n    };\n    this.baseUrl = config.baseUrl.replace(/\\/$/, \"\");\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n      ...config.headers\n    };\n    this.retry = typeof config?.retry === \"boolean\" && config?.retry === false ? {\n      attempts: 1,\n      backoff: () => 0\n    } : {\n      attempts: config?.retry?.retries ?? 5,\n      backoff: config?.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)\n    };\n  }\n  async request(req) {\n    const requestOptions = {\n      cache: this.options.cache,\n      method: \"POST\",\n      headers: this.headers,\n      body: JSON.stringify(req.body),\n      keepalive: true,\n      signal: this.options.signal\n    };\n    let res = null;\n    let error = null;\n    for (let i = 0; i <= this.retry.attempts; i++) {\n      try {\n        res = await fetch([this.baseUrl, ...req.path ?? []].join(\"/\"), requestOptions);\n        break;\n      } catch (error_) {\n        if (this.options.signal?.aborted) {\n          const myBlob = new Blob([\n            JSON.stringify({ result: this.options.signal.reason ?? \"Aborted\" })\n          ]);\n          const myOptions = {\n            status: 200,\n            statusText: this.options.signal.reason ?? \"Aborted\"\n          };\n          res = new Response(myBlob, myOptions);\n          break;\n        }\n        error = error_;\n        if (i < this.retry.attempts) {\n          await new Promise((r) => setTimeout(r, this.retry.backoff(i)));\n        }\n      }\n    }\n    if (!res) {\n      throw error ?? new Error(\"Exhausted all retries\");\n    }\n    const body = await res.json();\n    if (!res.ok) {\n      throw new UpstashError(`${body.error}`);\n    }\n    return { result: body.result, error: body.error };\n  }\n};\n\n// src/commands/client/query/types.ts\nvar WeightingStrategy = /* @__PURE__ */ ((WeightingStrategy2) => {\n  WeightingStrategy2[\"IDF\"] = \"IDF\";\n  return WeightingStrategy2;\n})(WeightingStrategy || {});\nvar FusionAlgorithm = /* @__PURE__ */ ((FusionAlgorithm2) => {\n  FusionAlgorithm2[\"RRF\"] = \"RRF\";\n  FusionAlgorithm2[\"DBSF\"] = \"DBSF\";\n  return FusionAlgorithm2;\n})(FusionAlgorithm || {});\nvar QueryMode = /* @__PURE__ */ ((QueryMode2) => {\n  QueryMode2[\"HYBRID\"] = \"HYBRID\";\n  QueryMode2[\"DENSE\"] = \"DENSE\";\n  QueryMode2[\"SPARSE\"] = \"SPARSE\";\n  return QueryMode2;\n})(QueryMode || {});\n\n// src/commands/command.ts\nvar Command = class {\n  payload;\n  endpoint;\n  constructor(command, endpoint) {\n    this.payload = command;\n    this.endpoint = endpoint;\n  }\n  /**\n   * Execute the command using a client.\n   */\n  async exec(client) {\n    const { result, error } = await client.request({\n      body: this.payload,\n      path: [this.endpoint]\n    });\n    if (error) {\n      throw new UpstashError(error);\n    }\n    if (result === void 0) {\n      throw new TypeError(\"Request did not return a result\");\n    }\n    return result;\n  }\n};\n\n// src/commands/client/query/query-many/index.ts\nvar QueryManyCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"query\";\n    const hasData = payload.some((p) => p.data);\n    endpoint = hasData ? \"query-data\" : \"query\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/query/query-single/index.ts\nvar QueryCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"query\";\n    if (\"data\" in payload) {\n      endpoint = \"query-data\";\n    } else if (!payload.vector && !payload.sparseVector) {\n      throw new UpstashError(\"Either data, vector or sparseVector should be provided.\");\n    }\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/delete/index.ts\nvar DeleteCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"delete\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    if (typeof payload === \"string\" || typeof payload === \"number\") {\n      super(\n        {\n          ids: [payload]\n        },\n        endpoint\n      );\n    } else if (Array.isArray(payload)) {\n      super(\n        {\n          ids: payload\n        },\n        endpoint\n      );\n    } else if (typeof payload === \"object\") {\n      super(payload, endpoint);\n    }\n  }\n};\n\n// src/commands/client/upsert/index.ts\nvar UpsertCommand = class extends Command {\n  constructor(payload, opts) {\n    let endpoint = \"upsert\";\n    if (Array.isArray(payload)) {\n      const isUpsert = payload.some((p) => isVectorPayload(p));\n      endpoint = isUpsert ? \"upsert\" : \"upsert-data\";\n    } else {\n      endpoint = isVectorPayload(payload) ? \"upsert\" : \"upsert-data\";\n    }\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\nvar isVectorPayload = (payload) => {\n  return \"vector\" in payload || \"sparseVector\" in payload;\n};\n\n// src/commands/client/fetch/index.ts\nvar FetchCommand = class extends Command {\n  constructor([payload, opts]) {\n    let endpoint = \"fetch\";\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n      delete opts.namespace;\n    }\n    if (Array.isArray(payload)) {\n      super({ ids: payload, ...opts }, endpoint);\n    } else if (typeof payload === \"object\") {\n      super({ ...payload, ...opts }, endpoint);\n    } else {\n      throw new Error(\"Invalid payload\");\n    }\n  }\n};\n\n// src/commands/client/range/index.ts\nvar RangeCommand = class extends Command {\n  constructor(payload, options) {\n    let endpoint = \"range\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/reset/index.ts\nvar ResetCommand = class extends Command {\n  constructor(options) {\n    let endpoint = \"reset\";\n    if (options?.namespace) {\n      endpoint = `${endpoint}/${options.namespace}`;\n    } else if (options?.all) {\n      endpoint = `${endpoint}?all`;\n    }\n    super([], endpoint);\n  }\n};\n\n// src/commands/client/info/index.ts\nvar InfoCommand = class extends Command {\n  constructor() {\n    const endpoint = \"info\";\n    super([], endpoint);\n  }\n};\n\n// src/commands/client/resumable-query/resume.ts\nvar ResumeQueryCommand = class extends Command {\n  constructor(payload) {\n    super(payload, \"resumable-query-next\");\n  }\n};\n\n// src/commands/client/resumable-query/start.ts\nvar StartResumableQueryCommand = class extends Command {\n  constructor(payload, namespace) {\n    let endpoint = \"resumable-query\";\n    if (\"data\" in payload) {\n      endpoint = \"resumable-query-data\";\n    }\n    if (namespace) {\n      endpoint = `${endpoint}/${namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/client/resumable-query/stop.ts\nvar StopResumableQueryCommand = class extends Command {\n  constructor(payload) {\n    super(payload, \"resumable-query-end\");\n  }\n};\n\n// src/commands/client/resumable-query/index.ts\nvar ResumableQuery = class {\n  uuid;\n  start;\n  fetchNext;\n  stop;\n  constructor(payload, client, namespace) {\n    this.start = async () => {\n      const result = await new StartResumableQueryCommand(payload, namespace).exec(\n        client\n      );\n      this.uuid = result.uuid;\n      return result;\n    };\n    this.fetchNext = (additionalK) => {\n      if (!this.uuid) {\n        throw new Error(\n          \"The resumable query has already been stopped. Please start another resumable query.\"\n        );\n      }\n      return new ResumeQueryCommand({ uuid: this.uuid, additionalK }).exec(client);\n    };\n    this.stop = async () => {\n      if (!this.uuid) {\n        throw new Error(\"Resumable query has not been started. Call start() first.\");\n      }\n      const result = await new StopResumableQueryCommand({ uuid: this.uuid }).exec(client);\n      this.uuid = \"\";\n      return result;\n    };\n  }\n};\n\n// src/commands/client/namespace/index.ts\nvar Namespace = class {\n  client;\n  namespace;\n  /**\n   * Create a new index namespace client\n   *\n   * @example\n   * ```typescript\n   * const index = new Index({\n   *  url: \"<UPSTASH_VECTOR_REST_URL>\",\n   *  token: \"<UPSTASH_VECTOR_REST_TOKEN>\",\n   * });\n   *\n   * const namespace = index.namespace(\"ns\");\n   * ```\n   */\n  constructor(client, namespace) {\n    this.client = client;\n    this.namespace = namespace;\n  }\n  /**\n   * Upserts (Updates and Inserts) specific items into the index namespace.\n   * It's used for adding new items to the index namespace or updating existing ones.\n   *\n   * @example\n   * ```js\n   * const upsertArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const upsertResult = await index.namespace(\"ns\").upsert(upsertArgs);\n   * console.log(upsertResult); // Outputs the result of the upsert operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.\n   * @param {number|string} args.id - The unique identifier for the item being upserted.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Dict} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.\n   */\n  upsert = (args) => new UpsertCommand(args, { namespace: this.namespace }).exec(this.client);\n  /*\n   * Updates specific items in the index.\n   * It's used for updating existing items in the index.\n   *\n   * @example\n   * ```js\n   * const updateArgs = {\n   *   id: '123',\n   *   metadata: { updatedProperty: 'value1' }\n   * };\n   * const updateResult = await index.update(updateArgs);\n   * console.log(updateResult); // Outputs the result of the update operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpdateCommand>} args - The arguments for the update command.\n   * @param {number|string} args.id - The unique identifier for the item being updated.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {Promise<{updated: number}>} A promise that returns the number of items successfully updated.\n   */\n  update = (args) => new UpdateCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Fetches specific items from the index by their IDs or by an id prefix.\n   *\n   * Note: While using id prefix, the paginated `range` command is recommended to prevent timeouts on large result sets.\n   *\n   * @example\n   * ```js\n   * // Using ids\n   * await index.namespace(\"ns\").fetch([\"test-1\", \"test-2\"], { includeMetadata: true });\n   *\n   * // Using id prefix\n   * await index.namespace(\"ns\").fetch({ prefix: \"test-\" });\n   * ```\n   *\n   * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.\n   * @param {FetchPayload} args[0] - An array of IDs or the id prefix of the items to be fetched.\n   * @param {FetchCommandOptions} args[1] - Options for the fetch operation.\n   * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.\n   * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.\n   * @param {string} [args[1].namespace = \"\"] - The namespace of the index to fetch items from.\n   *\n   * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.\n   */\n  fetch = (...args) => {\n    if (args[1]) {\n      args[1].namespace = this.namespace;\n    } else {\n      args[1] = { namespace: this.namespace };\n    }\n    return new FetchCommand(args).exec(this.client);\n  };\n  /**\n   * Queries an index namespace with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.namespace(\"ns\").query({\n   *  topK: 3,\n   *  vector: [ 0.22, 0.66 ],\n   *  filter: \"age >= 23 and (type = \\'turtle\\' OR type = \\'cat\\')\"\n   * });\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   *\n   * @returns A promise that resolves with an array of query result objects when the request to query the index is completed.\n   */\n  query = (args) => new QueryCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Initializes a resumable query operation on the vector database.\n   * This method allows for querying large result sets in multiple chunks or implementing pagination.\n   *\n   * @template TMetadata\n   * @param {ResumableQueryPayload} args - The arguments for the resumable query.\n   * @param {number} args.maxIdle - The maximum idle time in seconds before the query session expires.\n   * @param {number} args.topK - The number of top results to return in each fetch operation.\n   * @param {number[]} args.vector - The query vector used for similarity search.\n   * @param {boolean} [args.includeMetadata] - Whether to include metadata in the query results.\n   * @param {boolean} [args.includeVectors] - Whether to include vectors in the query results.\n   * @param {Object} [options] - Additional options for the query.\n   * @returns {Promise<ResumableQuery<TMetadata>>} A promise that resolves to a ResumableQuery object.\n   * @example\n   * const { result, fetchNext, stop } = await index.namespace(\"ns\").resumableQuery({\n   *   maxIdle: 3600,\n   *   topK: 50,\n   *   vector: [0.1, 0.2, 0.3, ...],\n   *   includeMetadata: true,\n   *   includeVectors: true\n   * }, { namespace: 'my-namespace' });\n   *\n   * const firstBatch = await fetchNext(10);\n   * const secondBatch = await fetchNext(10);\n   * await stop(); // End the query session\n   */\n  resumableQuery = async (args) => {\n    const resumableQuery = new ResumableQuery(args, this.client, this.namespace);\n    const initialQuery = await resumableQuery.start();\n    const { fetchNext, stop } = resumableQuery;\n    return { fetchNext, stop, result: initialQuery.scores };\n  };\n  /**\n     * Deletes items from the index namespace by id, by id prefix, or by filter.\n     *\n     * @example\n     * ```js\n     * // Delete by id\n     * await index.namespace(\"ns\").delete(\"test-id\");\n  \n     * // Delete by ids\n     * await index.namespace(\"ns\").delete([\"test-id1\", \"test-id2\"]);\n  \n     * // Delete by id prefix\n     * await index.namespace(\"ns\").delete({ prefix: \"test-\" });\n  \n     * // Delete by filter\n     * await index.namespace(\"ns\").delete({ filter: \"age >= 23\" });\n     * ```\n     *\n     * @param args - A single id, an array of ids, a prefix, or a filter to delete items from the index.\n     * @returns Number of deleted vectors in the format `{ deleted: number }`.If no vectors are deleted, returns `{ deleted: 0 }`.\n     */\n  delete = (args) => new DeleteCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * Retrieves a paginated range of items from the index. Optionally filter results by an id prefix.\n   * Returns items in batches with a cursor for pagination.\n   *\n   * @example\n   * ```js\n   * const args = {\n   *   limit: 10,\n   *   includeVectors: true,\n   *   includeMetadata: false\n   * };\n   * await index.namespace(\"ns\").range(args);\n   *\n   * // Use the cursor to get the next page of results\n   * const nextPage = await index.namespace(\"ns\").range({\n   *   // You have to pass the arguments from the first call\n   *   ...args,\n   *   cursor: rangeResult.nextCursor,\n   * });\n   * ```\n   *\n   * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.\n   * @param {string} [args.prefix] - The prefix of the items to be fetched.\n   * @param {number|string} args.cursor - The starting point (cursor) for the range query.\n   * @param {number} args.limit - The maximum number of items to return in this range.\n   * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.\n   * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.\n   *\n   * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.\n   */\n  range = (args) => new RangeCommand(args, { namespace: this.namespace }).exec(this.client);\n  /**\n   * It's used for wiping all the vectors in a index namespace.\n   *\n   * @example\n   * ```js\n   * await index.namespace(\"ns\").reset();\n   * console.log('Index namespace has been reset');\n   * ```\n   *\n   * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.\n   */\n  reset = () => new ResetCommand({ namespace: this.namespace }).exec(this.client);\n};\n\n// src/commands/client/update/index.ts\nvar UpdateCommand = class extends Command {\n  constructor(payload, opts) {\n    let endpoint = \"update\";\n    if (opts?.namespace) {\n      endpoint = `${endpoint}/${opts.namespace}`;\n    }\n    super(payload, endpoint);\n  }\n};\n\n// src/commands/management/namespaces/list/index.ts\nvar ListNamespacesCommand = class extends Command {\n  constructor() {\n    const endpoint = \"list-namespaces\";\n    super([], endpoint);\n  }\n};\n\n// src/commands/management/namespaces/delete/index.ts\nvar DeleteNamespaceCommand = class extends Command {\n  constructor(namespace) {\n    const endpoint = `delete-namespace/${namespace}`;\n    super([], endpoint);\n  }\n};\n\n// src/vector.ts\nvar Index = class {\n  client;\n  /**\n   * Create a new vector db client\n   *\n   * @example\n   * ```typescript\n   * const index = new Index({\n   *  url: \"<UPSTASH_VECTOR_REST_URL>\",\n   *  token: \"<UPSTASH_VECTOR_REST_TOKEN>\",\n   * });\n   * ```\n   */\n  constructor(client) {\n    this.client = client;\n  }\n  namespace = (namespace) => new Namespace(this.client, namespace);\n  /**\n     * Deletes items from the index by id, by id prefix, or by filter.\n     *\n     * @example\n     * ```js\n     * // Delete by id\n     * await index.delete(\"test-id\");\n  \n     * // Delete by ids\n     * await index.delete([\"test-id1\", \"test-id2\"]);\n  \n     * // Delete by id prefix\n     * await index.delete({ prefix: \"test-\" });\n  \n     * // Delete by filter\n     * await index.delete({ filter: \"age >= 23\" });\n     * ```\n     *\n     * @param args - A single id, an array of ids, a prefix, or a filter to delete items from the index.\n     * @returns Number of deleted vectors in the format `{ deleted: number }`.If no vectors are deleted, returns `{ deleted: 0 }`.\n     */\n  delete = (args, options) => new DeleteCommand(args, options).exec(this.client);\n  /**\n   * Queries an index with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.query({\n   *  topK: 3,\n   *  vector: [ 0.22, 0.66 ],\n   *  filter: \"age >= 23 and (type = \\'turtle\\' OR type = \\'cat\\')\"\n   * });\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.\n   *\n   *  A promise that resolves with an array of query result objects when the request to query the index is completed.\n   */\n  query = (args, options) => new QueryCommand(args, options).exec(this.client);\n  /**\n   * Queries an index with specified parameters.\n   * This method creates and executes a query command on an index based on the provided arguments.\n   *\n   * @example\n   * ```js\n   * await index.queryMany([\n   * {\n   *     topK: 3,\n   *     vector: [0.22, 0.66],\n   *     filter: \"age >= 23 and (type = 'turtle' OR type = 'cat')\",\n   * },\n   * {\n   *     topK: 3,\n   *     vector: [0.45, 0.52],\n   *     filter: \"age >= 27 and (type = 'rabbit' OR type = 'dog')\",\n   * },\n   * ]);\n   *\n   * ```\n   *\n   * @param {Object} args - The arguments for the query command.\n   * @param {number[]} args.vector - An array of numbers representing the feature vector for the query.\n   *                                This vector is utilized to find the most relevant items in the index.\n   * @param {number} args.topK - The desired number of top results to be returned, based on relevance or similarity to the query vector.\n   * @param {string} [args.filter] - An optional filter string to be used in the query. The filter string is used to narrow down the query results.\n   * @param {boolean} [args.includeVectors=false] - When set to true, includes the feature vectors of the returned items in the response.\n   * @param {boolean} [args.includeMetadata=false] - When set to true, includes additional metadata of the returned items in the response.\n   * @param {boolean} [args.includeData=false] - When set to true, includes data - string - of the returned items in the response.\n   *\n   *  A promise that resolves with an array of arrays of query result objects,\n   *  where each inner array represents a group of results matching a specific query condition.\n   */\n  queryMany = (args, options) => new QueryManyCommand(args, options).exec(this.client);\n  /**\n   * Initializes a resumable query operation on the vector database.\n   * This method allows for querying large result sets in multiple chunks or implementing pagination.\n   *\n   * @template TMetadata\n   * @param {ResumableQueryPayload} args - The arguments for the resumable query.\n   * @param {number} args.maxIdle - The maximum idle time in seconds before the query session expires.\n   * @param {number} args.topK - The number of top results to return in each fetch operation.\n   * @param {number[]} args.vector - The query vector used for similarity search.\n   * @param {boolean} [args.includeMetadata] - Whether to include metadata in the query results.\n   * @param {boolean} [args.includeVectors] - Whether to include vectors in the query results.\n   * @param {Object} [options] - Additional options for the query.\n   * @param {string} [options.namespace] - The namespace to query within.\n   * @returns {Promise<ResumableQuery<TMetadata>>} A promise that resolves to a ResumableQuery object.\n   * @example\n   * const { result, fetchNext, stop } = await index.resumableQuery({\n   *   maxIdle: 3600,\n   *   topK: 50,\n   *   vector: [0.1, 0.2, 0.3, ...],\n   *   includeMetadata: true,\n   *   includeVectors: true\n   * }, { namespace: 'my-namespace' });\n   *\n   * const firstBatch = await fetchNext(10);\n   * const secondBatch = await fetchNext(10);\n   * await stop(); // End the query session\n   */\n  resumableQuery = async (args, options) => {\n    const resumableQuery = new ResumableQuery(args, this.client, options?.namespace);\n    const initialQuery = await resumableQuery.start();\n    const { fetchNext, stop } = resumableQuery;\n    return { fetchNext, stop, result: initialQuery.scores };\n  };\n  /**\n   * Upserts (Updates and Inserts) specific items into the index.\n   * It's used for adding new items to the index or updating existing ones.\n   *\n   * @example\n   * ```js\n   * const upsertArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const upsertResult = await index.upsert(upsertArgs);\n   * console.log(upsertResult); // Outputs the result of the upsert operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpsertCommand>} args - The arguments for the upsert command.\n   * @param {number|string} args.id - The unique identifier for the item being upserted.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   *\n   * @returns {string} A promise that resolves with the result of the upsert operation after the command is executed.\n   */\n  upsert = (args, options) => new UpsertCommand(args, options).exec(this.client);\n  /*\n   * Updates specific items in the index.\n   * It's used for updating existing items in the index.\n   *\n   * @example\n   * ```js\n   * const updateArgs = {\n   *   id: '123',\n   *   vector: [0.42, 0.87, ...],\n   *   metadata: { property1: 'value1', property2: 'value2' }\n   * };\n   * const updateResult = await index.update(updateArgs);\n   * console.log(updateResult); // Outputs the result of the update operation\n   * ```\n   *\n   * @param {CommandArgs<typeof UpdateCommand>} args - The arguments for the update command.\n   * @param {number|string} args.id - The unique identifier for the item being updated.\n   * @param {number[]} args.vector - The feature vector associated with the item.\n   * @param {Record<string, unknown>} [args.metadata] - Optional metadata to be associated with the item.\n   * @param {string} [args.namespace] - The namespace to update the item in.\n   *\n   * @returns {Promise<{updated: number}>} A promise that returns the number of items successfully updated.\n   */\n  update = (args, options) => new UpdateCommand(args, options).exec(this.client);\n  /**\n   * Fetches specific items from the index by their IDs or by an id prefix.\n   *\n   * Note: While using id prefix, the paginated `range` command is recommended to prevent timeouts on large result sets.\n   *\n   * @example\n   * ```js\n   * // Using ids\n   * await index.fetch([\"test-1\", \"test-2\"], { includeMetadata: true });\n   *\n   * // Using id prefix\n   * await index.fetch({ prefix: \"test-\" });\n   * ```\n   *\n   * @param {...CommandArgs<typeof FetchCommand>} args - The arguments for the fetch command.\n   * @param {FetchPayload} args[0] - An array of IDs or the id prefix of the items to be fetched.\n   * @param {FetchCommandOptions} args[1] - Options for the fetch operation.\n   * @param {boolean} [args[1].includeMetadata=false] - Optionally include metadata of the fetched items.\n   * @param {boolean} [args[1].includeVectors=false] - Optionally include feature vectors of the fetched items.\n   * @param {string} [args[1].namespace = \"\"] - The namespace of the index to fetch items from.\n   *\n   * @returns {Promise<FetchReturnResponse<TMetadata>[]>} A promise that resolves with an array of fetched items or null if not found, after the command is executed.\n   */\n  fetch = (...args) => new FetchCommand(args).exec(this.client);\n  /**\n   * It's used for wiping the index.\n   *\n   * By default, resets the default namespace:\n   *\n   * @example\n   * ```js\n   * await index.reset();\n   * console.log('Default namespace has been reset');\n   * ```\n   *\n   * To reset a namespace, call reset like:\n   *\n   * @example\n   * ```js\n   * await index.reset({ namespace: \"ns\" });\n   * console.log('Namespace ns has been reset');\n   * ```\n   *\n   * If you want to reset all namespaces, call reset like:\n   *\n   * @example\n   * ```js\n   * await index.reset({ all: true });\n   * console.log('All namespaces have been reset');\n   * ```\n   *\n   * @returns {Promise<string>} A promise that resolves with the result of the reset operation after the command is executed.\n   */\n  reset = (options) => new ResetCommand(options).exec(this.client);\n  /**\n   * Retrieves a paginated range of items from the index. Optionally filter results by an id prefix.\n   * Returns items in batches with a cursor for pagination.\n   *\n   * @example\n   * ```js\n   * const args = {\n   *   limit: 10,\n   *   includeVectors: true,\n   *   includeMetadata: false\n   * };\n   * await index.range(args);\n   *\n   * // Use the cursor to get the next page of results\n   * const nextPage = await index.range({\n   *   // You have to pass the arguments from the first call\n   *   ...args,\n   *   cursor: rangeResult.nextCursor,\n   * });\n   * ```\n   *\n   * @param {CommandArgs<typeof RangeCommand>} args - The arguments for the range command.\n   * @param {string} [args.prefix] - The prefix of the items to be fetched.\n   * @param {number|string} args.cursor - The starting point (cursor) for the range query.\n   * @param {number} args.limit - The maximum number of items to return in this range.\n   * @param {boolean} [args.includeVectors=false] - Optionally include the feature vectors of the items in the response.\n   * @param {boolean} [args.includeMetadata=false] - Optionally include additional metadata of the items in the response.\n   *\n   * @returns {Promise<RangeReturnResponse<TMetadata>>} A promise that resolves with the response containing the next cursor and an array of vectors, after the command is executed.\n   */\n  range = (args, options) => new RangeCommand(args, options).exec(this.client);\n  /**\n   * Retrieves info from the index.\n   *\n   * @example\n   * ```js\n   * const infoResults = await index.info();\n   * console.log(infoResults); // Outputs the result of the info operation\n   * ```\n   *\n   * @returns {Promise<InfoResult>} A promise that resolves with the response containing the vectorCount, pendingVectorCount, indexSize, dimension count and similarity algorithm after the command is executed.\n   */\n  info = () => new InfoCommand().exec(this.client);\n  /**\n   * List all namespaces in the vector database.\n   *\n   * @example\n   * ```js\n   * const namespaces = await index.listNamespaces();\n   * console.log(namespaces); // Outputs the list of namespaces\n   * ```\n   *\n   * @returns {Promise<string[]>} A promise that resolves with an array of namespaces after the command is executed.\n   */\n  listNamespaces = () => new ListNamespacesCommand().exec(this.client);\n  /**\n   * Deletes a namespace from the vector database.\n   *\n   * @example\n   * ```js\n   * await index.deleteNamespace('namespace');\n   * console.log('Namespace has been deleted');\n   * ```\n   *\n   * @param {string} namespace - The name of the namespace to be deleted.\n   * @returns {Promise<string>} A promise that resolves with the result of the delete operation after the command is executed.\n   */\n  deleteNamespace = (namespace) => new DeleteNamespaceCommand(namespace).exec(this.client);\n};\n\n// version.ts\nvar VERSION = \"v1.2.1\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHVwc3Rhc2gvdmVjdG9yL2Rpc3QvY2h1bmstSEVTRUdUMkEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSw2QkFBNkIsaURBQWlEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUJBQXlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEdBQUcsa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBU0UiLCJzb3VyY2VzIjpbIi9ob21lL210YWhhc3lsbXovRGVza3RvcC91cHN0YXNoL21hc3RyYS93aXRoQXBpL25vZGVfbW9kdWxlcy9AdXBzdGFzaC92ZWN0b3IvZGlzdC9jaHVuay1IRVNFR1QyQS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9yL2luZGV4LnRzXG52YXIgVXBzdGFzaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVwc3Rhc2hFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvaHR0cC9pbmRleC50c1xudmFyIEh0dHBDbGllbnQgPSBjbGFzcyB7XG4gIGJhc2VVcmw7XG4gIGhlYWRlcnM7XG4gIG9wdGlvbnM7XG4gIHJldHJ5O1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBjYWNoZTogY29uZmlnLmNhY2hlLFxuICAgICAgc2lnbmFsOiBjb25maWcuc2lnbmFsXG4gICAgfTtcbiAgICB0aGlzLmJhc2VVcmwgPSBjb25maWcuYmFzZVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5jb25maWcuaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5yZXRyeSA9IHR5cGVvZiBjb25maWc/LnJldHJ5ID09PSBcImJvb2xlYW5cIiAmJiBjb25maWc/LnJldHJ5ID09PSBmYWxzZSA/IHtcbiAgICAgIGF0dGVtcHRzOiAxLFxuICAgICAgYmFja29mZjogKCkgPT4gMFxuICAgIH0gOiB7XG4gICAgICBhdHRlbXB0czogY29uZmlnPy5yZXRyeT8ucmV0cmllcyA/PyA1LFxuICAgICAgYmFja29mZjogY29uZmlnPy5yZXRyeT8uYmFja29mZiA/PyAoKHJldHJ5Q291bnQpID0+IE1hdGguZXhwKHJldHJ5Q291bnQpICogNTApXG4gICAgfTtcbiAgfVxuICBhc3luYyByZXF1ZXN0KHJlcSkge1xuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgY2FjaGU6IHRoaXMub3B0aW9ucy5jYWNoZSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXEuYm9keSksXG4gICAgICBrZWVwYWxpdmU6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMub3B0aW9ucy5zaWduYWxcbiAgICB9O1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5yZXRyeS5hdHRlbXB0czsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChbdGhpcy5iYXNlVXJsLCAuLi5yZXEucGF0aCA/PyBbXV0uam9pbihcIi9cIiksIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICBjb25zdCBteUJsb2IgPSBuZXcgQmxvYihbXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHJlc3VsdDogdGhpcy5vcHRpb25zLnNpZ25hbC5yZWFzb24gPz8gXCJBYm9ydGVkXCIgfSlcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBjb25zdCBteU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHRoaXMub3B0aW9ucy5zaWduYWwucmVhc29uID8/IFwiQWJvcnRlZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXMgPSBuZXcgUmVzcG9uc2UobXlCbG9iLCBteU9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3JfO1xuICAgICAgICBpZiAoaSA8IHRoaXMucmV0cnkuYXR0ZW1wdHMpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCB0aGlzLnJldHJ5LmJhY2tvZmYoaSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlcykge1xuICAgICAgdGhyb3cgZXJyb3IgPz8gbmV3IEVycm9yKFwiRXhoYXVzdGVkIGFsbCByZXRyaWVzXCIpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IFVwc3Rhc2hFcnJvcihgJHtib2R5LmVycm9yfWApO1xuICAgIH1cbiAgICByZXR1cm4geyByZXN1bHQ6IGJvZHkucmVzdWx0LCBlcnJvcjogYm9keS5lcnJvciB9O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xpZW50L3F1ZXJ5L3R5cGVzLnRzXG52YXIgV2VpZ2h0aW5nU3RyYXRlZ3kgPSAvKiBAX19QVVJFX18gKi8gKChXZWlnaHRpbmdTdHJhdGVneTIpID0+IHtcbiAgV2VpZ2h0aW5nU3RyYXRlZ3kyW1wiSURGXCJdID0gXCJJREZcIjtcbiAgcmV0dXJuIFdlaWdodGluZ1N0cmF0ZWd5Mjtcbn0pKFdlaWdodGluZ1N0cmF0ZWd5IHx8IHt9KTtcbnZhciBGdXNpb25BbGdvcml0aG0gPSAvKiBAX19QVVJFX18gKi8gKChGdXNpb25BbGdvcml0aG0yKSA9PiB7XG4gIEZ1c2lvbkFsZ29yaXRobTJbXCJSUkZcIl0gPSBcIlJSRlwiO1xuICBGdXNpb25BbGdvcml0aG0yW1wiREJTRlwiXSA9IFwiREJTRlwiO1xuICByZXR1cm4gRnVzaW9uQWxnb3JpdGhtMjtcbn0pKEZ1c2lvbkFsZ29yaXRobSB8fCB7fSk7XG52YXIgUXVlcnlNb2RlID0gLyogQF9fUFVSRV9fICovICgoUXVlcnlNb2RlMikgPT4ge1xuICBRdWVyeU1vZGUyW1wiSFlCUklEXCJdID0gXCJIWUJSSURcIjtcbiAgUXVlcnlNb2RlMltcIkRFTlNFXCJdID0gXCJERU5TRVwiO1xuICBRdWVyeU1vZGUyW1wiU1BBUlNFXCJdID0gXCJTUEFSU0VcIjtcbiAgcmV0dXJuIFF1ZXJ5TW9kZTI7XG59KShRdWVyeU1vZGUgfHwge30pO1xuXG4vLyBzcmMvY29tbWFuZHMvY29tbWFuZC50c1xudmFyIENvbW1hbmQgPSBjbGFzcyB7XG4gIHBheWxvYWQ7XG4gIGVuZHBvaW50O1xuICBjb25zdHJ1Y3Rvcihjb21tYW5kLCBlbmRwb2ludCkge1xuICAgIHRoaXMucGF5bG9hZCA9IGNvbW1hbmQ7XG4gICAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBjb21tYW5kIHVzaW5nIGEgY2xpZW50LlxuICAgKi9cbiAgYXN5bmMgZXhlYyhjbGllbnQpIHtcbiAgICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIGJvZHk6IHRoaXMucGF5bG9hZCxcbiAgICAgIHBhdGg6IFt0aGlzLmVuZHBvaW50XVxuICAgIH0pO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVwc3Rhc2hFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlcXVlc3QgZGlkIG5vdCByZXR1cm4gYSByZXN1bHRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvcXVlcnkvcXVlcnktbWFueS9pbmRleC50c1xudmFyIFF1ZXJ5TWFueUNvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgbGV0IGVuZHBvaW50ID0gXCJxdWVyeVwiO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBwYXlsb2FkLnNvbWUoKHApID0+IHAuZGF0YSk7XG4gICAgZW5kcG9pbnQgPSBoYXNEYXRhID8gXCJxdWVyeS1kYXRhXCIgOiBcInF1ZXJ5XCI7XG4gICAgaWYgKG9wdGlvbnM/Lm5hbWVzcGFjZSkge1xuICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0vJHtvcHRpb25zLm5hbWVzcGFjZX1gO1xuICAgIH1cbiAgICBzdXBlcihwYXlsb2FkLCBlbmRwb2ludCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvcXVlcnkvcXVlcnktc2luZ2xlL2luZGV4LnRzXG52YXIgUXVlcnlDb21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGxldCBlbmRwb2ludCA9IFwicXVlcnlcIjtcbiAgICBpZiAoXCJkYXRhXCIgaW4gcGF5bG9hZCkge1xuICAgICAgZW5kcG9pbnQgPSBcInF1ZXJ5LWRhdGFcIjtcbiAgICB9IGVsc2UgaWYgKCFwYXlsb2FkLnZlY3RvciAmJiAhcGF5bG9hZC5zcGFyc2VWZWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBVcHN0YXNoRXJyb3IoXCJFaXRoZXIgZGF0YSwgdmVjdG9yIG9yIHNwYXJzZVZlY3RvciBzaG91bGQgYmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ubmFtZXNwYWNlKSB7XG4gICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS8ke29wdGlvbnMubmFtZXNwYWNlfWA7XG4gICAgfVxuICAgIHN1cGVyKHBheWxvYWQsIGVuZHBvaW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsaWVudC9kZWxldGUvaW5kZXgudHNcbnZhciBEZWxldGVDb21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGxldCBlbmRwb2ludCA9IFwiZGVsZXRlXCI7XG4gICAgaWYgKG9wdGlvbnM/Lm5hbWVzcGFjZSkge1xuICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0vJHtvcHRpb25zLm5hbWVzcGFjZX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHN1cGVyKFxuICAgICAgICB7XG4gICAgICAgICAgaWRzOiBbcGF5bG9hZF1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kcG9pbnRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICBzdXBlcihcbiAgICAgICAge1xuICAgICAgICAgIGlkczogcGF5bG9hZFxuICAgICAgICB9LFxuICAgICAgICBlbmRwb2ludFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBzdXBlcihwYXlsb2FkLCBlbmRwb2ludCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xpZW50L3Vwc2VydC9pbmRleC50c1xudmFyIFVwc2VydENvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBvcHRzKSB7XG4gICAgbGV0IGVuZHBvaW50ID0gXCJ1cHNlcnRcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgY29uc3QgaXNVcHNlcnQgPSBwYXlsb2FkLnNvbWUoKHApID0+IGlzVmVjdG9yUGF5bG9hZChwKSk7XG4gICAgICBlbmRwb2ludCA9IGlzVXBzZXJ0ID8gXCJ1cHNlcnRcIiA6IFwidXBzZXJ0LWRhdGFcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kcG9pbnQgPSBpc1ZlY3RvclBheWxvYWQocGF5bG9hZCkgPyBcInVwc2VydFwiIDogXCJ1cHNlcnQtZGF0YVwiO1xuICAgIH1cbiAgICBpZiAob3B0cz8ubmFtZXNwYWNlKSB7XG4gICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS8ke29wdHMubmFtZXNwYWNlfWA7XG4gICAgfVxuICAgIHN1cGVyKHBheWxvYWQsIGVuZHBvaW50KTtcbiAgfVxufTtcbnZhciBpc1ZlY3RvclBheWxvYWQgPSAocGF5bG9hZCkgPT4ge1xuICByZXR1cm4gXCJ2ZWN0b3JcIiBpbiBwYXlsb2FkIHx8IFwic3BhcnNlVmVjdG9yXCIgaW4gcGF5bG9hZDtcbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvZmV0Y2gvaW5kZXgudHNcbnZhciBGZXRjaENvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihbcGF5bG9hZCwgb3B0c10pIHtcbiAgICBsZXQgZW5kcG9pbnQgPSBcImZldGNoXCI7XG4gICAgaWYgKG9wdHM/Lm5hbWVzcGFjZSkge1xuICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0vJHtvcHRzLm5hbWVzcGFjZX1gO1xuICAgICAgZGVsZXRlIG9wdHMubmFtZXNwYWNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgc3VwZXIoeyBpZHM6IHBheWxvYWQsIC4uLm9wdHMgfSwgZW5kcG9pbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHN1cGVyKHsgLi4ucGF5bG9hZCwgLi4ub3B0cyB9LCBlbmRwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF5bG9hZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvcmFuZ2UvaW5kZXgudHNcbnZhciBSYW5nZUNvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgbGV0IGVuZHBvaW50ID0gXCJyYW5nZVwiO1xuICAgIGlmIChvcHRpb25zPy5uYW1lc3BhY2UpIHtcbiAgICAgIGVuZHBvaW50ID0gYCR7ZW5kcG9pbnR9LyR7b3B0aW9ucy5uYW1lc3BhY2V9YDtcbiAgICB9XG4gICAgc3VwZXIocGF5bG9hZCwgZW5kcG9pbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xpZW50L3Jlc2V0L2luZGV4LnRzXG52YXIgUmVzZXRDb21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGxldCBlbmRwb2ludCA9IFwicmVzZXRcIjtcbiAgICBpZiAob3B0aW9ucz8ubmFtZXNwYWNlKSB7XG4gICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS8ke29wdGlvbnMubmFtZXNwYWNlfWA7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zPy5hbGwpIHtcbiAgICAgIGVuZHBvaW50ID0gYCR7ZW5kcG9pbnR9P2FsbGA7XG4gICAgfVxuICAgIHN1cGVyKFtdLCBlbmRwb2ludCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvaW5mby9pbmRleC50c1xudmFyIEluZm9Db21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBcImluZm9cIjtcbiAgICBzdXBlcihbXSwgZW5kcG9pbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xpZW50L3Jlc3VtYWJsZS1xdWVyeS9yZXN1bWUudHNcbnZhciBSZXN1bWVRdWVyeUNvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkKSB7XG4gICAgc3VwZXIocGF5bG9hZCwgXCJyZXN1bWFibGUtcXVlcnktbmV4dFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsaWVudC9yZXN1bWFibGUtcXVlcnkvc3RhcnQudHNcbnZhciBTdGFydFJlc3VtYWJsZVF1ZXJ5Q29tbWFuZCA9IGNsYXNzIGV4dGVuZHMgQ29tbWFuZCB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG5hbWVzcGFjZSkge1xuICAgIGxldCBlbmRwb2ludCA9IFwicmVzdW1hYmxlLXF1ZXJ5XCI7XG4gICAgaWYgKFwiZGF0YVwiIGluIHBheWxvYWQpIHtcbiAgICAgIGVuZHBvaW50ID0gXCJyZXN1bWFibGUtcXVlcnktZGF0YVwiO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBlbmRwb2ludCA9IGAke2VuZHBvaW50fS8ke25hbWVzcGFjZX1gO1xuICAgIH1cbiAgICBzdXBlcihwYXlsb2FkLCBlbmRwb2ludCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9jbGllbnQvcmVzdW1hYmxlLXF1ZXJ5L3N0b3AudHNcbnZhciBTdG9wUmVzdW1hYmxlUXVlcnlDb21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCkge1xuICAgIHN1cGVyKHBheWxvYWQsIFwicmVzdW1hYmxlLXF1ZXJ5LWVuZFwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsaWVudC9yZXN1bWFibGUtcXVlcnkvaW5kZXgudHNcbnZhciBSZXN1bWFibGVRdWVyeSA9IGNsYXNzIHtcbiAgdXVpZDtcbiAgc3RhcnQ7XG4gIGZldGNoTmV4dDtcbiAgc3RvcDtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgY2xpZW50LCBuYW1lc3BhY2UpIHtcbiAgICB0aGlzLnN0YXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFN0YXJ0UmVzdW1hYmxlUXVlcnlDb21tYW5kKHBheWxvYWQsIG5hbWVzcGFjZSkuZXhlYyhcbiAgICAgICAgY2xpZW50XG4gICAgICApO1xuICAgICAgdGhpcy51dWlkID0gcmVzdWx0LnV1aWQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgdGhpcy5mZXRjaE5leHQgPSAoYWRkaXRpb25hbEspID0+IHtcbiAgICAgIGlmICghdGhpcy51dWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRoZSByZXN1bWFibGUgcXVlcnkgaGFzIGFscmVhZHkgYmVlbiBzdG9wcGVkLiBQbGVhc2Ugc3RhcnQgYW5vdGhlciByZXN1bWFibGUgcXVlcnkuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVzdW1lUXVlcnlDb21tYW5kKHsgdXVpZDogdGhpcy51dWlkLCBhZGRpdGlvbmFsSyB9KS5leGVjKGNsaWVudCk7XG4gICAgfTtcbiAgICB0aGlzLnN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXVpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXN1bWFibGUgcXVlcnkgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQuIENhbGwgc3RhcnQoKSBmaXJzdC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgU3RvcFJlc3VtYWJsZVF1ZXJ5Q29tbWFuZCh7IHV1aWQ6IHRoaXMudXVpZCB9KS5leGVjKGNsaWVudCk7XG4gICAgICB0aGlzLnV1aWQgPSBcIlwiO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvY2xpZW50L25hbWVzcGFjZS9pbmRleC50c1xudmFyIE5hbWVzcGFjZSA9IGNsYXNzIHtcbiAgY2xpZW50O1xuICBuYW1lc3BhY2U7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5kZXggbmFtZXNwYWNlIGNsaWVudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gbmV3IEluZGV4KHtcbiAgICogIHVybDogXCI8VVBTVEFTSF9WRUNUT1JfUkVTVF9VUkw+XCIsXG4gICAqICB0b2tlbjogXCI8VVBTVEFTSF9WRUNUT1JfUkVTVF9UT0tFTj5cIixcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IG5hbWVzcGFjZSA9IGluZGV4Lm5hbWVzcGFjZShcIm5zXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgbmFtZXNwYWNlKSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIH1cbiAgLyoqXG4gICAqIFVwc2VydHMgKFVwZGF0ZXMgYW5kIEluc2VydHMpIHNwZWNpZmljIGl0ZW1zIGludG8gdGhlIGluZGV4IG5hbWVzcGFjZS5cbiAgICogSXQncyB1c2VkIGZvciBhZGRpbmcgbmV3IGl0ZW1zIHRvIHRoZSBpbmRleCBuYW1lc3BhY2Ugb3IgdXBkYXRpbmcgZXhpc3Rpbmcgb25lcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgdXBzZXJ0QXJncyA9IHtcbiAgICogICBpZDogJzEyMycsXG4gICAqICAgdmVjdG9yOiBbMC40MiwgMC44NywgLi4uXSxcbiAgICogICBtZXRhZGF0YTogeyBwcm9wZXJ0eTE6ICd2YWx1ZTEnLCBwcm9wZXJ0eTI6ICd2YWx1ZTInIH1cbiAgICogfTtcbiAgICogY29uc3QgdXBzZXJ0UmVzdWx0ID0gYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikudXBzZXJ0KHVwc2VydEFyZ3MpO1xuICAgKiBjb25zb2xlLmxvZyh1cHNlcnRSZXN1bHQpOyAvLyBPdXRwdXRzIHRoZSByZXN1bHQgb2YgdGhlIHVwc2VydCBvcGVyYXRpb25cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tbWFuZEFyZ3M8dHlwZW9mIFVwc2VydENvbW1hbmQ+fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHVwc2VydCBjb21tYW5kLlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGFyZ3MuaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtIGJlaW5nIHVwc2VydGVkLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIFRoZSBmZWF0dXJlIHZlY3RvciBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uXG4gICAqIEBwYXJhbSB7RGljdH0gW2FyZ3MubWV0YWRhdGFdIC0gT3B0aW9uYWwgbWV0YWRhdGEgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHVwc2VydCBvcGVyYXRpb24gYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICB1cHNlcnQgPSAoYXJncykgPT4gbmV3IFVwc2VydENvbW1hbmQoYXJncywgeyBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlIH0pLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKlxuICAgKiBVcGRhdGVzIHNwZWNpZmljIGl0ZW1zIGluIHRoZSBpbmRleC5cbiAgICogSXQncyB1c2VkIGZvciB1cGRhdGluZyBleGlzdGluZyBpdGVtcyBpbiB0aGUgaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHVwZGF0ZUFyZ3MgPSB7XG4gICAqICAgaWQ6ICcxMjMnLFxuICAgKiAgIG1ldGFkYXRhOiB7IHVwZGF0ZWRQcm9wZXJ0eTogJ3ZhbHVlMScgfVxuICAgKiB9O1xuICAgKiBjb25zdCB1cGRhdGVSZXN1bHQgPSBhd2FpdCBpbmRleC51cGRhdGUodXBkYXRlQXJncyk7XG4gICAqIGNvbnNvbGUubG9nKHVwZGF0ZVJlc3VsdCk7IC8vIE91dHB1dHMgdGhlIHJlc3VsdCBvZiB0aGUgdXBkYXRlIG9wZXJhdGlvblxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtDb21tYW5kQXJnczx0eXBlb2YgVXBkYXRlQ29tbWFuZD59IGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgdXBkYXRlIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gYXJncy5pZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGl0ZW0gYmVpbmcgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJncy52ZWN0b3IgLSBUaGUgZmVhdHVyZSB2ZWN0b3IgYXNzb2NpYXRlZCB3aXRoIHRoZSBpdGVtLlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBbYXJncy5tZXRhZGF0YV0gLSBPcHRpb25hbCBtZXRhZGF0YSB0byBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHt1cGRhdGVkOiBudW1iZXJ9Pn0gQSBwcm9taXNlIHRoYXQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLlxuICAgKi9cbiAgdXBkYXRlID0gKGFyZ3MpID0+IG5ldyBVcGRhdGVDb21tYW5kKGFyZ3MsIHsgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9KS5leGVjKHRoaXMuY2xpZW50KTtcbiAgLyoqXG4gICAqIEZldGNoZXMgc3BlY2lmaWMgaXRlbXMgZnJvbSB0aGUgaW5kZXggYnkgdGhlaXIgSURzIG9yIGJ5IGFuIGlkIHByZWZpeC5cbiAgICpcbiAgICogTm90ZTogV2hpbGUgdXNpbmcgaWQgcHJlZml4LCB0aGUgcGFnaW5hdGVkIGByYW5nZWAgY29tbWFuZCBpcyByZWNvbW1lbmRlZCB0byBwcmV2ZW50IHRpbWVvdXRzIG9uIGxhcmdlIHJlc3VsdCBzZXRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAvLyBVc2luZyBpZHNcbiAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikuZmV0Y2goW1widGVzdC0xXCIsIFwidGVzdC0yXCJdLCB7IGluY2x1ZGVNZXRhZGF0YTogdHJ1ZSB9KTtcbiAgICpcbiAgICogLy8gVXNpbmcgaWQgcHJlZml4XG4gICAqIGF3YWl0IGluZGV4Lm5hbWVzcGFjZShcIm5zXCIpLmZldGNoKHsgcHJlZml4OiBcInRlc3QtXCIgfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gey4uLkNvbW1hbmRBcmdzPHR5cGVvZiBGZXRjaENvbW1hbmQ+fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZldGNoIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7RmV0Y2hQYXlsb2FkfSBhcmdzWzBdIC0gQW4gYXJyYXkgb2YgSURzIG9yIHRoZSBpZCBwcmVmaXggb2YgdGhlIGl0ZW1zIHRvIGJlIGZldGNoZWQuXG4gICAqIEBwYXJhbSB7RmV0Y2hDb21tYW5kT3B0aW9uc30gYXJnc1sxXSAtIE9wdGlvbnMgZm9yIHRoZSBmZXRjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3NbMV0uaW5jbHVkZU1ldGFkYXRhPWZhbHNlXSAtIE9wdGlvbmFsbHkgaW5jbHVkZSBtZXRhZGF0YSBvZiB0aGUgZmV0Y2hlZCBpdGVtcy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJnc1sxXS5pbmNsdWRlVmVjdG9ycz1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgZmVhdHVyZSB2ZWN0b3JzIG9mIHRoZSBmZXRjaGVkIGl0ZW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3NbMV0ubmFtZXNwYWNlID0gXCJcIl0gLSBUaGUgbmFtZXNwYWNlIG9mIHRoZSBpbmRleCB0byBmZXRjaCBpdGVtcyBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJldHVyblJlc3BvbnNlPFRNZXRhZGF0YT5bXT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgZmV0Y2hlZCBpdGVtcyBvciBudWxsIGlmIG5vdCBmb3VuZCwgYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICBmZXRjaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgIGFyZ3NbMV0ubmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NbMV0gPSB7IG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGZXRjaENvbW1hbmQoYXJncykuZXhlYyh0aGlzLmNsaWVudCk7XG4gIH07XG4gIC8qKlxuICAgKiBRdWVyaWVzIGFuIGluZGV4IG5hbWVzcGFjZSB3aXRoIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGFuZCBleGVjdXRlcyBhIHF1ZXJ5IGNvbW1hbmQgb24gYW4gaW5kZXggYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikucXVlcnkoe1xuICAgKiAgdG9wSzogMyxcbiAgICogIHZlY3RvcjogWyAwLjIyLCAwLjY2IF0sXG4gICAqICBmaWx0ZXI6IFwiYWdlID49IDIzIGFuZCAodHlwZSA9IFxcJ3R1cnRsZVxcJyBPUiB0eXBlID0gXFwnY2F0XFwnKVwiXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgcXVlcnkgY29tbWFuZC5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJncy52ZWN0b3IgLSBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgZmVhdHVyZSB2ZWN0b3IgZm9yIHRoZSBxdWVyeS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgdmVjdG9yIGlzIHV0aWxpemVkIHRvIGZpbmQgdGhlIG1vc3QgcmVsZXZhbnQgaXRlbXMgaW4gdGhlIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy50b3BLIC0gVGhlIGRlc2lyZWQgbnVtYmVyIG9mIHRvcCByZXN1bHRzIHRvIGJlIHJldHVybmVkLCBiYXNlZCBvbiByZWxldmFuY2Ugb3Igc2ltaWxhcml0eSB0byB0aGUgcXVlcnkgdmVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZmlsdGVyXSAtIEFuIG9wdGlvbmFsIGZpbHRlciBzdHJpbmcgdG8gYmUgdXNlZCBpbiB0aGUgcXVlcnkuIFRoZSBmaWx0ZXIgc3RyaW5nIGlzIHVzZWQgdG8gbmFycm93IGRvd24gdGhlIHF1ZXJ5IHJlc3VsdHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuaW5jbHVkZVZlY3RvcnM9ZmFsc2VdIC0gV2hlbiBzZXQgdG8gdHJ1ZSwgaW5jbHVkZXMgdGhlIGZlYXR1cmUgdmVjdG9ycyBvZiB0aGUgcmV0dXJuZWQgaXRlbXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmluY2x1ZGVNZXRhZGF0YT1mYWxzZV0gLSBXaGVuIHNldCB0byB0cnVlLCBpbmNsdWRlcyBhZGRpdGlvbmFsIG1ldGFkYXRhIG9mIHRoZSByZXR1cm5lZCBpdGVtcyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgcXVlcnkgcmVzdWx0IG9iamVjdHMgd2hlbiB0aGUgcmVxdWVzdCB0byBxdWVyeSB0aGUgaW5kZXggaXMgY29tcGxldGVkLlxuICAgKi9cbiAgcXVlcnkgPSAoYXJncykgPT4gbmV3IFF1ZXJ5Q29tbWFuZChhcmdzLCB7IG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2UgfSkuZXhlYyh0aGlzLmNsaWVudCk7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHJlc3VtYWJsZSBxdWVyeSBvcGVyYXRpb24gb24gdGhlIHZlY3RvciBkYXRhYmFzZS5cbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGZvciBxdWVyeWluZyBsYXJnZSByZXN1bHQgc2V0cyBpbiBtdWx0aXBsZSBjaHVua3Mgb3IgaW1wbGVtZW50aW5nIHBhZ2luYXRpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUTWV0YWRhdGFcbiAgICogQHBhcmFtIHtSZXN1bWFibGVRdWVyeVBheWxvYWR9IGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgcmVzdW1hYmxlIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5tYXhJZGxlIC0gVGhlIG1heGltdW0gaWRsZSB0aW1lIGluIHNlY29uZHMgYmVmb3JlIHRoZSBxdWVyeSBzZXNzaW9uIGV4cGlyZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLnRvcEsgLSBUaGUgbnVtYmVyIG9mIHRvcCByZXN1bHRzIHRvIHJldHVybiBpbiBlYWNoIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJncy52ZWN0b3IgLSBUaGUgcXVlcnkgdmVjdG9yIHVzZWQgZm9yIHNpbWlsYXJpdHkgc2VhcmNoLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmluY2x1ZGVNZXRhZGF0YV0gLSBXaGV0aGVyIHRvIGluY2x1ZGUgbWV0YWRhdGEgaW4gdGhlIHF1ZXJ5IHJlc3VsdHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuaW5jbHVkZVZlY3RvcnNdIC0gV2hldGhlciB0byBpbmNsdWRlIHZlY3RvcnMgaW4gdGhlIHF1ZXJ5IHJlc3VsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBxdWVyeS5cbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzdW1hYmxlUXVlcnk8VE1ldGFkYXRhPj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgUmVzdW1hYmxlUXVlcnkgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB7IHJlc3VsdCwgZmV0Y2hOZXh0LCBzdG9wIH0gPSBhd2FpdCBpbmRleC5uYW1lc3BhY2UoXCJuc1wiKS5yZXN1bWFibGVRdWVyeSh7XG4gICAqICAgbWF4SWRsZTogMzYwMCxcbiAgICogICB0b3BLOiA1MCxcbiAgICogICB2ZWN0b3I6IFswLjEsIDAuMiwgMC4zLCAuLi5dLFxuICAgKiAgIGluY2x1ZGVNZXRhZGF0YTogdHJ1ZSxcbiAgICogICBpbmNsdWRlVmVjdG9yczogdHJ1ZVxuICAgKiB9LCB7IG5hbWVzcGFjZTogJ215LW5hbWVzcGFjZScgfSk7XG4gICAqXG4gICAqIGNvbnN0IGZpcnN0QmF0Y2ggPSBhd2FpdCBmZXRjaE5leHQoMTApO1xuICAgKiBjb25zdCBzZWNvbmRCYXRjaCA9IGF3YWl0IGZldGNoTmV4dCgxMCk7XG4gICAqIGF3YWl0IHN0b3AoKTsgLy8gRW5kIHRoZSBxdWVyeSBzZXNzaW9uXG4gICAqL1xuICByZXN1bWFibGVRdWVyeSA9IGFzeW5jIChhcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdW1hYmxlUXVlcnkgPSBuZXcgUmVzdW1hYmxlUXVlcnkoYXJncywgdGhpcy5jbGllbnQsIHRoaXMubmFtZXNwYWNlKTtcbiAgICBjb25zdCBpbml0aWFsUXVlcnkgPSBhd2FpdCByZXN1bWFibGVRdWVyeS5zdGFydCgpO1xuICAgIGNvbnN0IHsgZmV0Y2hOZXh0LCBzdG9wIH0gPSByZXN1bWFibGVRdWVyeTtcbiAgICByZXR1cm4geyBmZXRjaE5leHQsIHN0b3AsIHJlc3VsdDogaW5pdGlhbFF1ZXJ5LnNjb3JlcyB9O1xuICB9O1xuICAvKipcbiAgICAgKiBEZWxldGVzIGl0ZW1zIGZyb20gdGhlIGluZGV4IG5hbWVzcGFjZSBieSBpZCwgYnkgaWQgcHJlZml4LCBvciBieSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkXG4gICAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikuZGVsZXRlKFwidGVzdC1pZFwiKTtcbiAgXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkc1xuICAgICAqIGF3YWl0IGluZGV4Lm5hbWVzcGFjZShcIm5zXCIpLmRlbGV0ZShbXCJ0ZXN0LWlkMVwiLCBcInRlc3QtaWQyXCJdKTtcbiAgXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkIHByZWZpeFxuICAgICAqIGF3YWl0IGluZGV4Lm5hbWVzcGFjZShcIm5zXCIpLmRlbGV0ZSh7IHByZWZpeDogXCJ0ZXN0LVwiIH0pO1xuICBcbiAgICAgKiAvLyBEZWxldGUgYnkgZmlsdGVyXG4gICAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikuZGVsZXRlKHsgZmlsdGVyOiBcImFnZSA+PSAyM1wiIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBIHNpbmdsZSBpZCwgYW4gYXJyYXkgb2YgaWRzLCBhIHByZWZpeCwgb3IgYSBmaWx0ZXIgdG8gZGVsZXRlIGl0ZW1zIGZyb20gdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBkZWxldGVkIHZlY3RvcnMgaW4gdGhlIGZvcm1hdCBgeyBkZWxldGVkOiBudW1iZXIgfWAuSWYgbm8gdmVjdG9ycyBhcmUgZGVsZXRlZCwgcmV0dXJucyBgeyBkZWxldGVkOiAwIH1gLlxuICAgICAqL1xuICBkZWxldGUgPSAoYXJncykgPT4gbmV3IERlbGV0ZUNvbW1hbmQoYXJncywgeyBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlIH0pLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKipcbiAgICogUmV0cmlldmVzIGEgcGFnaW5hdGVkIHJhbmdlIG9mIGl0ZW1zIGZyb20gdGhlIGluZGV4LiBPcHRpb25hbGx5IGZpbHRlciByZXN1bHRzIGJ5IGFuIGlkIHByZWZpeC5cbiAgICogUmV0dXJucyBpdGVtcyBpbiBiYXRjaGVzIHdpdGggYSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGFyZ3MgPSB7XG4gICAqICAgbGltaXQ6IDEwLFxuICAgKiAgIGluY2x1ZGVWZWN0b3JzOiB0cnVlLFxuICAgKiAgIGluY2x1ZGVNZXRhZGF0YTogZmFsc2VcbiAgICogfTtcbiAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikucmFuZ2UoYXJncyk7XG4gICAqXG4gICAqIC8vIFVzZSB0aGUgY3Vyc29yIHRvIGdldCB0aGUgbmV4dCBwYWdlIG9mIHJlc3VsdHNcbiAgICogY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBpbmRleC5uYW1lc3BhY2UoXCJuc1wiKS5yYW5nZSh7XG4gICAqICAgLy8gWW91IGhhdmUgdG8gcGFzcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGZpcnN0IGNhbGxcbiAgICogICAuLi5hcmdzLFxuICAgKiAgIGN1cnNvcjogcmFuZ2VSZXN1bHQubmV4dEN1cnNvcixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0NvbW1hbmRBcmdzPHR5cGVvZiBSYW5nZUNvbW1hbmQ+fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHJhbmdlIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5wcmVmaXhdIC0gVGhlIHByZWZpeCBvZiB0aGUgaXRlbXMgdG8gYmUgZmV0Y2hlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBhcmdzLmN1cnNvciAtIFRoZSBzdGFydGluZyBwb2ludCAoY3Vyc29yKSBmb3IgdGhlIHJhbmdlIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4gaW4gdGhpcyByYW5nZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlVmVjdG9ycz1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgdGhlIGZlYXR1cmUgdmVjdG9ycyBvZiB0aGUgaXRlbXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmluY2x1ZGVNZXRhZGF0YT1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgYWRkaXRpb25hbCBtZXRhZGF0YSBvZiB0aGUgaXRlbXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSYW5nZVJldHVyblJlc3BvbnNlPFRNZXRhZGF0YT4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBuZXh0IGN1cnNvciBhbmQgYW4gYXJyYXkgb2YgdmVjdG9ycywgYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICByYW5nZSA9IChhcmdzKSA9PiBuZXcgUmFuZ2VDb21tYW5kKGFyZ3MsIHsgbmFtZXNwYWNlOiB0aGlzLm5hbWVzcGFjZSB9KS5leGVjKHRoaXMuY2xpZW50KTtcbiAgLyoqXG4gICAqIEl0J3MgdXNlZCBmb3Igd2lwaW5nIGFsbCB0aGUgdmVjdG9ycyBpbiBhIGluZGV4IG5hbWVzcGFjZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogYXdhaXQgaW5kZXgubmFtZXNwYWNlKFwibnNcIikucmVzZXQoKTtcbiAgICogY29uc29sZS5sb2coJ0luZGV4IG5hbWVzcGFjZSBoYXMgYmVlbiByZXNldCcpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSByZXNldCBvcGVyYXRpb24gYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICByZXNldCA9ICgpID0+IG5ldyBSZXNldENvbW1hbmQoeyBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlIH0pLmV4ZWModGhpcy5jbGllbnQpO1xufTtcblxuLy8gc3JjL2NvbW1hbmRzL2NsaWVudC91cGRhdGUvaW5kZXgudHNcbnZhciBVcGRhdGVDb21tYW5kID0gY2xhc3MgZXh0ZW5kcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgb3B0cykge1xuICAgIGxldCBlbmRwb2ludCA9IFwidXBkYXRlXCI7XG4gICAgaWYgKG9wdHM/Lm5hbWVzcGFjZSkge1xuICAgICAgZW5kcG9pbnQgPSBgJHtlbmRwb2ludH0vJHtvcHRzLm5hbWVzcGFjZX1gO1xuICAgIH1cbiAgICBzdXBlcihwYXlsb2FkLCBlbmRwb2ludCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21tYW5kcy9tYW5hZ2VtZW50L25hbWVzcGFjZXMvbGlzdC9pbmRleC50c1xudmFyIExpc3ROYW1lc3BhY2VzQ29tbWFuZCA9IGNsYXNzIGV4dGVuZHMgQ29tbWFuZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gXCJsaXN0LW5hbWVzcGFjZXNcIjtcbiAgICBzdXBlcihbXSwgZW5kcG9pbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvY29tbWFuZHMvbWFuYWdlbWVudC9uYW1lc3BhY2VzL2RlbGV0ZS9pbmRleC50c1xudmFyIERlbGV0ZU5hbWVzcGFjZUNvbW1hbmQgPSBjbGFzcyBleHRlbmRzIENvbW1hbmQge1xuICBjb25zdHJ1Y3RvcihuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IGBkZWxldGUtbmFtZXNwYWNlLyR7bmFtZXNwYWNlfWA7XG4gICAgc3VwZXIoW10sIGVuZHBvaW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3ZlY3Rvci50c1xudmFyIEluZGV4ID0gY2xhc3Mge1xuICBjbGllbnQ7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmVjdG9yIGRiIGNsaWVudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGluZGV4ID0gbmV3IEluZGV4KHtcbiAgICogIHVybDogXCI8VVBTVEFTSF9WRUNUT1JfUkVTVF9VUkw+XCIsXG4gICAqICB0b2tlbjogXCI8VVBTVEFTSF9WRUNUT1JfUkVTVF9UT0tFTj5cIixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gIH1cbiAgbmFtZXNwYWNlID0gKG5hbWVzcGFjZSkgPT4gbmV3IE5hbWVzcGFjZSh0aGlzLmNsaWVudCwgbmFtZXNwYWNlKTtcbiAgLyoqXG4gICAgICogRGVsZXRlcyBpdGVtcyBmcm9tIHRoZSBpbmRleCBieSBpZCwgYnkgaWQgcHJlZml4LCBvciBieSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkXG4gICAgICogYXdhaXQgaW5kZXguZGVsZXRlKFwidGVzdC1pZFwiKTtcbiAgXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkc1xuICAgICAqIGF3YWl0IGluZGV4LmRlbGV0ZShbXCJ0ZXN0LWlkMVwiLCBcInRlc3QtaWQyXCJdKTtcbiAgXG4gICAgICogLy8gRGVsZXRlIGJ5IGlkIHByZWZpeFxuICAgICAqIGF3YWl0IGluZGV4LmRlbGV0ZSh7IHByZWZpeDogXCJ0ZXN0LVwiIH0pO1xuICBcbiAgICAgKiAvLyBEZWxldGUgYnkgZmlsdGVyXG4gICAgICogYXdhaXQgaW5kZXguZGVsZXRlKHsgZmlsdGVyOiBcImFnZSA+PSAyM1wiIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBIHNpbmdsZSBpZCwgYW4gYXJyYXkgb2YgaWRzLCBhIHByZWZpeCwgb3IgYSBmaWx0ZXIgdG8gZGVsZXRlIGl0ZW1zIGZyb20gdGhlIGluZGV4LlxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBkZWxldGVkIHZlY3RvcnMgaW4gdGhlIGZvcm1hdCBgeyBkZWxldGVkOiBudW1iZXIgfWAuSWYgbm8gdmVjdG9ycyBhcmUgZGVsZXRlZCwgcmV0dXJucyBgeyBkZWxldGVkOiAwIH1gLlxuICAgICAqL1xuICBkZWxldGUgPSAoYXJncywgb3B0aW9ucykgPT4gbmV3IERlbGV0ZUNvbW1hbmQoYXJncywgb3B0aW9ucykuZXhlYyh0aGlzLmNsaWVudCk7XG4gIC8qKlxuICAgKiBRdWVyaWVzIGFuIGluZGV4IHdpdGggc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYW5kIGV4ZWN1dGVzIGEgcXVlcnkgY29tbWFuZCBvbiBhbiBpbmRleCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBpbmRleC5xdWVyeSh7XG4gICAqICB0b3BLOiAzLFxuICAgKiAgdmVjdG9yOiBbIDAuMjIsIDAuNjYgXSxcbiAgICogIGZpbHRlcjogXCJhZ2UgPj0gMjMgYW5kICh0eXBlID0gXFwndHVydGxlXFwnIE9SIHR5cGUgPSBcXCdjYXRcXCcpXCJcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBxdWVyeSBjb21tYW5kLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBmZWF0dXJlIHZlY3RvciBmb3IgdGhlIHF1ZXJ5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB2ZWN0b3IgaXMgdXRpbGl6ZWQgdG8gZmluZCB0aGUgbW9zdCByZWxldmFudCBpdGVtcyBpbiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLnRvcEsgLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gYmUgcmV0dXJuZWQsIGJhc2VkIG9uIHJlbGV2YW5jZSBvciBzaW1pbGFyaXR5IHRvIHRoZSBxdWVyeSB2ZWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWx0ZXJdIC0gQW4gb3B0aW9uYWwgZmlsdGVyIHN0cmluZyB0byBiZSB1c2VkIGluIHRoZSBxdWVyeS4gVGhlIGZpbHRlciBzdHJpbmcgaXMgdXNlZCB0byBuYXJyb3cgZG93biB0aGUgcXVlcnkgcmVzdWx0cy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlVmVjdG9ycz1mYWxzZV0gLSBXaGVuIHNldCB0byB0cnVlLCBpbmNsdWRlcyB0aGUgZmVhdHVyZSB2ZWN0b3JzIG9mIHRoZSByZXR1cm5lZCBpdGVtcyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuaW5jbHVkZU1ldGFkYXRhPWZhbHNlXSAtIFdoZW4gc2V0IHRvIHRydWUsIGluY2x1ZGVzIGFkZGl0aW9uYWwgbWV0YWRhdGEgb2YgdGhlIHJldHVybmVkIGl0ZW1zIGluIHRoZSByZXNwb25zZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlRGF0YT1mYWxzZV0gLSBXaGVuIHNldCB0byB0cnVlLCBpbmNsdWRlcyBkYXRhIC0gc3RyaW5nIC0gb2YgdGhlIHJldHVybmVkIGl0ZW1zIGluIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgcXVlcnkgcmVzdWx0IG9iamVjdHMgd2hlbiB0aGUgcmVxdWVzdCB0byBxdWVyeSB0aGUgaW5kZXggaXMgY29tcGxldGVkLlxuICAgKi9cbiAgcXVlcnkgPSAoYXJncywgb3B0aW9ucykgPT4gbmV3IFF1ZXJ5Q29tbWFuZChhcmdzLCBvcHRpb25zKS5leGVjKHRoaXMuY2xpZW50KTtcbiAgLyoqXG4gICAqIFF1ZXJpZXMgYW4gaW5kZXggd2l0aCBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhbmQgZXhlY3V0ZXMgYSBxdWVyeSBjb21tYW5kIG9uIGFuIGluZGV4IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGluZGV4LnF1ZXJ5TWFueShbXG4gICAqIHtcbiAgICogICAgIHRvcEs6IDMsXG4gICAqICAgICB2ZWN0b3I6IFswLjIyLCAwLjY2XSxcbiAgICogICAgIGZpbHRlcjogXCJhZ2UgPj0gMjMgYW5kICh0eXBlID0gJ3R1cnRsZScgT1IgdHlwZSA9ICdjYXQnKVwiLFxuICAgKiB9LFxuICAgKiB7XG4gICAqICAgICB0b3BLOiAzLFxuICAgKiAgICAgdmVjdG9yOiBbMC40NSwgMC41Ml0sXG4gICAqICAgICBmaWx0ZXI6IFwiYWdlID49IDI3IGFuZCAodHlwZSA9ICdyYWJiaXQnIE9SIHR5cGUgPSAnZG9nJylcIixcbiAgICogfSxcbiAgICogXSk7XG4gICAqXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBxdWVyeSBjb21tYW5kLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBmZWF0dXJlIHZlY3RvciBmb3IgdGhlIHF1ZXJ5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyB2ZWN0b3IgaXMgdXRpbGl6ZWQgdG8gZmluZCB0aGUgbW9zdCByZWxldmFudCBpdGVtcyBpbiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLnRvcEsgLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gYmUgcmV0dXJuZWQsIGJhc2VkIG9uIHJlbGV2YW5jZSBvciBzaW1pbGFyaXR5IHRvIHRoZSBxdWVyeSB2ZWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWx0ZXJdIC0gQW4gb3B0aW9uYWwgZmlsdGVyIHN0cmluZyB0byBiZSB1c2VkIGluIHRoZSBxdWVyeS4gVGhlIGZpbHRlciBzdHJpbmcgaXMgdXNlZCB0byBuYXJyb3cgZG93biB0aGUgcXVlcnkgcmVzdWx0cy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlVmVjdG9ycz1mYWxzZV0gLSBXaGVuIHNldCB0byB0cnVlLCBpbmNsdWRlcyB0aGUgZmVhdHVyZSB2ZWN0b3JzIG9mIHRoZSByZXR1cm5lZCBpdGVtcyBpbiB0aGUgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuaW5jbHVkZU1ldGFkYXRhPWZhbHNlXSAtIFdoZW4gc2V0IHRvIHRydWUsIGluY2x1ZGVzIGFkZGl0aW9uYWwgbWV0YWRhdGEgb2YgdGhlIHJldHVybmVkIGl0ZW1zIGluIHRoZSByZXNwb25zZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlRGF0YT1mYWxzZV0gLSBXaGVuIHNldCB0byB0cnVlLCBpbmNsdWRlcyBkYXRhIC0gc3RyaW5nIC0gb2YgdGhlIHJldHVybmVkIGl0ZW1zIGluIHRoZSByZXNwb25zZS5cbiAgICpcbiAgICogIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHF1ZXJ5IHJlc3VsdCBvYmplY3RzLFxuICAgKiAgd2hlcmUgZWFjaCBpbm5lciBhcnJheSByZXByZXNlbnRzIGEgZ3JvdXAgb2YgcmVzdWx0cyBtYXRjaGluZyBhIHNwZWNpZmljIHF1ZXJ5IGNvbmRpdGlvbi5cbiAgICovXG4gIHF1ZXJ5TWFueSA9IChhcmdzLCBvcHRpb25zKSA9PiBuZXcgUXVlcnlNYW55Q29tbWFuZChhcmdzLCBvcHRpb25zKS5leGVjKHRoaXMuY2xpZW50KTtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgcmVzdW1hYmxlIHF1ZXJ5IG9wZXJhdGlvbiBvbiB0aGUgdmVjdG9yIGRhdGFiYXNlLlxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIHF1ZXJ5aW5nIGxhcmdlIHJlc3VsdCBzZXRzIGluIG11bHRpcGxlIGNodW5rcyBvciBpbXBsZW1lbnRpbmcgcGFnaW5hdGlvbi5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRNZXRhZGF0YVxuICAgKiBAcGFyYW0ge1Jlc3VtYWJsZVF1ZXJ5UGF5bG9hZH0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSByZXN1bWFibGUgcXVlcnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLm1heElkbGUgLSBUaGUgbWF4aW11bSBpZGxlIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgdGhlIHF1ZXJ5IHNlc3Npb24gZXhwaXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MudG9wSyAtIFRoZSBudW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gcmV0dXJuIGluIGVhY2ggZmV0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIFRoZSBxdWVyeSB2ZWN0b3IgdXNlZCBmb3Igc2ltaWxhcml0eSBzZWFyY2guXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuaW5jbHVkZU1ldGFkYXRhXSAtIFdoZXRoZXIgdG8gaW5jbHVkZSBtZXRhZGF0YSBpbiB0aGUgcXVlcnkgcmVzdWx0cy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlVmVjdG9yc10gLSBXaGV0aGVyIHRvIGluY2x1ZGUgdmVjdG9ycyBpbiB0aGUgcXVlcnkgcmVzdWx0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZXNwYWNlXSAtIFRoZSBuYW1lc3BhY2UgdG8gcXVlcnkgd2l0aGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bWFibGVRdWVyeTxUTWV0YWRhdGE+Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBSZXN1bWFibGVRdWVyeSBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHsgcmVzdWx0LCBmZXRjaE5leHQsIHN0b3AgfSA9IGF3YWl0IGluZGV4LnJlc3VtYWJsZVF1ZXJ5KHtcbiAgICogICBtYXhJZGxlOiAzNjAwLFxuICAgKiAgIHRvcEs6IDUwLFxuICAgKiAgIHZlY3RvcjogWzAuMSwgMC4yLCAwLjMsIC4uLl0sXG4gICAqICAgaW5jbHVkZU1ldGFkYXRhOiB0cnVlLFxuICAgKiAgIGluY2x1ZGVWZWN0b3JzOiB0cnVlXG4gICAqIH0sIHsgbmFtZXNwYWNlOiAnbXktbmFtZXNwYWNlJyB9KTtcbiAgICpcbiAgICogY29uc3QgZmlyc3RCYXRjaCA9IGF3YWl0IGZldGNoTmV4dCgxMCk7XG4gICAqIGNvbnN0IHNlY29uZEJhdGNoID0gYXdhaXQgZmV0Y2hOZXh0KDEwKTtcbiAgICogYXdhaXQgc3RvcCgpOyAvLyBFbmQgdGhlIHF1ZXJ5IHNlc3Npb25cbiAgICovXG4gIHJlc3VtYWJsZVF1ZXJ5ID0gYXN5bmMgKGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCByZXN1bWFibGVRdWVyeSA9IG5ldyBSZXN1bWFibGVRdWVyeShhcmdzLCB0aGlzLmNsaWVudCwgb3B0aW9ucz8ubmFtZXNwYWNlKTtcbiAgICBjb25zdCBpbml0aWFsUXVlcnkgPSBhd2FpdCByZXN1bWFibGVRdWVyeS5zdGFydCgpO1xuICAgIGNvbnN0IHsgZmV0Y2hOZXh0LCBzdG9wIH0gPSByZXN1bWFibGVRdWVyeTtcbiAgICByZXR1cm4geyBmZXRjaE5leHQsIHN0b3AsIHJlc3VsdDogaW5pdGlhbFF1ZXJ5LnNjb3JlcyB9O1xuICB9O1xuICAvKipcbiAgICogVXBzZXJ0cyAoVXBkYXRlcyBhbmQgSW5zZXJ0cykgc3BlY2lmaWMgaXRlbXMgaW50byB0aGUgaW5kZXguXG4gICAqIEl0J3MgdXNlZCBmb3IgYWRkaW5nIG5ldyBpdGVtcyB0byB0aGUgaW5kZXggb3IgdXBkYXRpbmcgZXhpc3Rpbmcgb25lcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgdXBzZXJ0QXJncyA9IHtcbiAgICogICBpZDogJzEyMycsXG4gICAqICAgdmVjdG9yOiBbMC40MiwgMC44NywgLi4uXSxcbiAgICogICBtZXRhZGF0YTogeyBwcm9wZXJ0eTE6ICd2YWx1ZTEnLCBwcm9wZXJ0eTI6ICd2YWx1ZTInIH1cbiAgICogfTtcbiAgICogY29uc3QgdXBzZXJ0UmVzdWx0ID0gYXdhaXQgaW5kZXgudXBzZXJ0KHVwc2VydEFyZ3MpO1xuICAgKiBjb25zb2xlLmxvZyh1cHNlcnRSZXN1bHQpOyAvLyBPdXRwdXRzIHRoZSByZXN1bHQgb2YgdGhlIHVwc2VydCBvcGVyYXRpb25cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tbWFuZEFyZ3M8dHlwZW9mIFVwc2VydENvbW1hbmQ+fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHVwc2VydCBjb21tYW5kLlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGFyZ3MuaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBpdGVtIGJlaW5nIHVwc2VydGVkLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIFRoZSBmZWF0dXJlIHZlY3RvciBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFthcmdzLm1ldGFkYXRhXSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSB1cHNlcnQgb3BlcmF0aW9uIGFmdGVyIHRoZSBjb21tYW5kIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgdXBzZXJ0ID0gKGFyZ3MsIG9wdGlvbnMpID0+IG5ldyBVcHNlcnRDb21tYW5kKGFyZ3MsIG9wdGlvbnMpLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKlxuICAgKiBVcGRhdGVzIHNwZWNpZmljIGl0ZW1zIGluIHRoZSBpbmRleC5cbiAgICogSXQncyB1c2VkIGZvciB1cGRhdGluZyBleGlzdGluZyBpdGVtcyBpbiB0aGUgaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHVwZGF0ZUFyZ3MgPSB7XG4gICAqICAgaWQ6ICcxMjMnLFxuICAgKiAgIHZlY3RvcjogWzAuNDIsIDAuODcsIC4uLl0sXG4gICAqICAgbWV0YWRhdGE6IHsgcHJvcGVydHkxOiAndmFsdWUxJywgcHJvcGVydHkyOiAndmFsdWUyJyB9XG4gICAqIH07XG4gICAqIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IGluZGV4LnVwZGF0ZSh1cGRhdGVBcmdzKTtcbiAgICogY29uc29sZS5sb2codXBkYXRlUmVzdWx0KTsgLy8gT3V0cHV0cyB0aGUgcmVzdWx0IG9mIHRoZSB1cGRhdGUgb3BlcmF0aW9uXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0NvbW1hbmRBcmdzPHR5cGVvZiBVcGRhdGVDb21tYW5kPn0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSB1cGRhdGUgY29tbWFuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBhcmdzLmlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgaXRlbSBiZWluZyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLnZlY3RvciAtIFRoZSBmZWF0dXJlIHZlY3RvciBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0uXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IFthcmdzLm1ldGFkYXRhXSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm5hbWVzcGFjZV0gLSBUaGUgbmFtZXNwYWNlIHRvIHVwZGF0ZSB0aGUgaXRlbSBpbi5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8e3VwZGF0ZWQ6IG51bWJlcn0+fSBBIHByb21pc2UgdGhhdCByZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQuXG4gICAqL1xuICB1cGRhdGUgPSAoYXJncywgb3B0aW9ucykgPT4gbmV3IFVwZGF0ZUNvbW1hbmQoYXJncywgb3B0aW9ucykuZXhlYyh0aGlzLmNsaWVudCk7XG4gIC8qKlxuICAgKiBGZXRjaGVzIHNwZWNpZmljIGl0ZW1zIGZyb20gdGhlIGluZGV4IGJ5IHRoZWlyIElEcyBvciBieSBhbiBpZCBwcmVmaXguXG4gICAqXG4gICAqIE5vdGU6IFdoaWxlIHVzaW5nIGlkIHByZWZpeCwgdGhlIHBhZ2luYXRlZCBgcmFuZ2VgIGNvbW1hbmQgaXMgcmVjb21tZW5kZWQgdG8gcHJldmVudCB0aW1lb3V0cyBvbiBsYXJnZSByZXN1bHQgc2V0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLy8gVXNpbmcgaWRzXG4gICAqIGF3YWl0IGluZGV4LmZldGNoKFtcInRlc3QtMVwiLCBcInRlc3QtMlwiXSwgeyBpbmNsdWRlTWV0YWRhdGE6IHRydWUgfSk7XG4gICAqXG4gICAqIC8vIFVzaW5nIGlkIHByZWZpeFxuICAgKiBhd2FpdCBpbmRleC5mZXRjaCh7IHByZWZpeDogXCJ0ZXN0LVwiIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHsuLi5Db21tYW5kQXJnczx0eXBlb2YgRmV0Y2hDb21tYW5kPn0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBmZXRjaCBjb21tYW5kLlxuICAgKiBAcGFyYW0ge0ZldGNoUGF5bG9hZH0gYXJnc1swXSAtIEFuIGFycmF5IG9mIElEcyBvciB0aGUgaWQgcHJlZml4IG9mIHRoZSBpdGVtcyB0byBiZSBmZXRjaGVkLlxuICAgKiBAcGFyYW0ge0ZldGNoQ29tbWFuZE9wdGlvbnN9IGFyZ3NbMV0gLSBPcHRpb25zIGZvciB0aGUgZmV0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzWzFdLmluY2x1ZGVNZXRhZGF0YT1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgbWV0YWRhdGEgb2YgdGhlIGZldGNoZWQgaXRlbXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3NbMV0uaW5jbHVkZVZlY3RvcnM9ZmFsc2VdIC0gT3B0aW9uYWxseSBpbmNsdWRlIGZlYXR1cmUgdmVjdG9ycyBvZiB0aGUgZmV0Y2hlZCBpdGVtcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFthcmdzWzFdLm5hbWVzcGFjZSA9IFwiXCJdIC0gVGhlIG5hbWVzcGFjZSBvZiB0aGUgaW5kZXggdG8gZmV0Y2ggaXRlbXMgZnJvbS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZXR1cm5SZXNwb25zZTxUTWV0YWRhdGE+W10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIGZldGNoZWQgaXRlbXMgb3IgbnVsbCBpZiBub3QgZm91bmQsIGFmdGVyIHRoZSBjb21tYW5kIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgZmV0Y2ggPSAoLi4uYXJncykgPT4gbmV3IEZldGNoQ29tbWFuZChhcmdzKS5leGVjKHRoaXMuY2xpZW50KTtcbiAgLyoqXG4gICAqIEl0J3MgdXNlZCBmb3Igd2lwaW5nIHRoZSBpbmRleC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgcmVzZXRzIHRoZSBkZWZhdWx0IG5hbWVzcGFjZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogYXdhaXQgaW5kZXgucmVzZXQoKTtcbiAgICogY29uc29sZS5sb2coJ0RlZmF1bHQgbmFtZXNwYWNlIGhhcyBiZWVuIHJlc2V0Jyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUbyByZXNldCBhIG5hbWVzcGFjZSwgY2FsbCByZXNldCBsaWtlOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBpbmRleC5yZXNldCh7IG5hbWVzcGFjZTogXCJuc1wiIH0pO1xuICAgKiBjb25zb2xlLmxvZygnTmFtZXNwYWNlIG5zIGhhcyBiZWVuIHJlc2V0Jyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byByZXNldCBhbGwgbmFtZXNwYWNlcywgY2FsbCByZXNldCBsaWtlOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBhd2FpdCBpbmRleC5yZXNldCh7IGFsbDogdHJ1ZSB9KTtcbiAgICogY29uc29sZS5sb2coJ0FsbCBuYW1lc3BhY2VzIGhhdmUgYmVlbiByZXNldCcpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSByZXNldCBvcGVyYXRpb24gYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICByZXNldCA9IChvcHRpb25zKSA9PiBuZXcgUmVzZXRDb21tYW5kKG9wdGlvbnMpLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKipcbiAgICogUmV0cmlldmVzIGEgcGFnaW5hdGVkIHJhbmdlIG9mIGl0ZW1zIGZyb20gdGhlIGluZGV4LiBPcHRpb25hbGx5IGZpbHRlciByZXN1bHRzIGJ5IGFuIGlkIHByZWZpeC5cbiAgICogUmV0dXJucyBpdGVtcyBpbiBiYXRjaGVzIHdpdGggYSBjdXJzb3IgZm9yIHBhZ2luYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGFyZ3MgPSB7XG4gICAqICAgbGltaXQ6IDEwLFxuICAgKiAgIGluY2x1ZGVWZWN0b3JzOiB0cnVlLFxuICAgKiAgIGluY2x1ZGVNZXRhZGF0YTogZmFsc2VcbiAgICogfTtcbiAgICogYXdhaXQgaW5kZXgucmFuZ2UoYXJncyk7XG4gICAqXG4gICAqIC8vIFVzZSB0aGUgY3Vyc29yIHRvIGdldCB0aGUgbmV4dCBwYWdlIG9mIHJlc3VsdHNcbiAgICogY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBpbmRleC5yYW5nZSh7XG4gICAqICAgLy8gWW91IGhhdmUgdG8gcGFzcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGZpcnN0IGNhbGxcbiAgICogICAuLi5hcmdzLFxuICAgKiAgIGN1cnNvcjogcmFuZ2VSZXN1bHQubmV4dEN1cnNvcixcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge0NvbW1hbmRBcmdzPHR5cGVvZiBSYW5nZUNvbW1hbmQ+fSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIHJhbmdlIGNvbW1hbmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5wcmVmaXhdIC0gVGhlIHByZWZpeCBvZiB0aGUgaXRlbXMgdG8gYmUgZmV0Y2hlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBhcmdzLmN1cnNvciAtIFRoZSBzdGFydGluZyBwb2ludCAoY3Vyc29yKSBmb3IgdGhlIHJhbmdlIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4gaW4gdGhpcyByYW5nZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXJncy5pbmNsdWRlVmVjdG9ycz1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgdGhlIGZlYXR1cmUgdmVjdG9ycyBvZiB0aGUgaXRlbXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmluY2x1ZGVNZXRhZGF0YT1mYWxzZV0gLSBPcHRpb25hbGx5IGluY2x1ZGUgYWRkaXRpb25hbCBtZXRhZGF0YSBvZiB0aGUgaXRlbXMgaW4gdGhlIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSYW5nZVJldHVyblJlc3BvbnNlPFRNZXRhZGF0YT4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBuZXh0IGN1cnNvciBhbmQgYW4gYXJyYXkgb2YgdmVjdG9ycywgYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICByYW5nZSA9IChhcmdzLCBvcHRpb25zKSA9PiBuZXcgUmFuZ2VDb21tYW5kKGFyZ3MsIG9wdGlvbnMpLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKipcbiAgICogUmV0cmlldmVzIGluZm8gZnJvbSB0aGUgaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGluZm9SZXN1bHRzID0gYXdhaXQgaW5kZXguaW5mbygpO1xuICAgKiBjb25zb2xlLmxvZyhpbmZvUmVzdWx0cyk7IC8vIE91dHB1dHMgdGhlIHJlc3VsdCBvZiB0aGUgaW5mbyBvcGVyYXRpb25cbiAgICogYGBgXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEluZm9SZXN1bHQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSB2ZWN0b3JDb3VudCwgcGVuZGluZ1ZlY3RvckNvdW50LCBpbmRleFNpemUsIGRpbWVuc2lvbiBjb3VudCBhbmQgc2ltaWxhcml0eSBhbGdvcml0aG0gYWZ0ZXIgdGhlIGNvbW1hbmQgaXMgZXhlY3V0ZWQuXG4gICAqL1xuICBpbmZvID0gKCkgPT4gbmV3IEluZm9Db21tYW5kKCkuZXhlYyh0aGlzLmNsaWVudCk7XG4gIC8qKlxuICAgKiBMaXN0IGFsbCBuYW1lc3BhY2VzIGluIHRoZSB2ZWN0b3IgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG5hbWVzcGFjZXMgPSBhd2FpdCBpbmRleC5saXN0TmFtZXNwYWNlcygpO1xuICAgKiBjb25zb2xlLmxvZyhuYW1lc3BhY2VzKTsgLy8gT3V0cHV0cyB0aGUgbGlzdCBvZiBuYW1lc3BhY2VzXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2YgbmFtZXNwYWNlcyBhZnRlciB0aGUgY29tbWFuZCBpcyBleGVjdXRlZC5cbiAgICovXG4gIGxpc3ROYW1lc3BhY2VzID0gKCkgPT4gbmV3IExpc3ROYW1lc3BhY2VzQ29tbWFuZCgpLmV4ZWModGhpcy5jbGllbnQpO1xuICAvKipcbiAgICogRGVsZXRlcyBhIG5hbWVzcGFjZSBmcm9tIHRoZSB2ZWN0b3IgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGluZGV4LmRlbGV0ZU5hbWVzcGFjZSgnbmFtZXNwYWNlJyk7XG4gICAqIGNvbnNvbGUubG9nKCdOYW1lc3BhY2UgaGFzIGJlZW4gZGVsZXRlZCcpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIFRoZSBuYW1lIG9mIHRoZSBuYW1lc3BhY2UgdG8gYmUgZGVsZXRlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBkZWxldGUgb3BlcmF0aW9uIGFmdGVyIHRoZSBjb21tYW5kIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgZGVsZXRlTmFtZXNwYWNlID0gKG5hbWVzcGFjZSkgPT4gbmV3IERlbGV0ZU5hbWVzcGFjZUNvbW1hbmQobmFtZXNwYWNlKS5leGVjKHRoaXMuY2xpZW50KTtcbn07XG5cbi8vIHZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gXCJ2MS4yLjFcIjtcblxuZXhwb3J0IHtcbiAgSHR0cENsaWVudCxcbiAgV2VpZ2h0aW5nU3RyYXRlZ3ksXG4gIEZ1c2lvbkFsZ29yaXRobSxcbiAgUXVlcnlNb2RlLFxuICBJbmRleCxcbiAgVkVSU0lPTlxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@upstash/vector/dist/chunk-HESEGT2A.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@upstash/vector/dist/nodejs.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@upstash/vector/dist/nodejs.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FusionAlgorithm: () => (/* reexport safe */ _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.FusionAlgorithm),\n/* harmony export */   Index: () => (/* binding */ Index2),\n/* harmony export */   QueryMode: () => (/* reexport safe */ _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.QueryMode),\n/* harmony export */   WeightingStrategy: () => (/* reexport safe */ _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.WeightingStrategy)\n/* harmony export */ });\n/* harmony import */ var _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-HESEGT2A.mjs */ \"(rsc)/./node_modules/@upstash/vector/dist/chunk-HESEGT2A.mjs\");\n\n\n// src/utils/get-runtime.ts\nfunction getRuntime() {\n  if (typeof process === \"object\" && typeof process.versions == \"object\" && process.versions.bun)\n    return `bun@${process.versions.bun}`;\n  return typeof EdgeRuntime === \"string\" ? \"edge-light\" : `node@${process.version}`;\n}\n\n// src/platforms/nodejs.ts\nvar Index2 = class _Index extends _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.Index {\n  constructor(configOrRequester) {\n    if (configOrRequester !== void 0 && \"request\" in configOrRequester) {\n      super(configOrRequester);\n      return;\n    }\n    const token = configOrRequester?.token ?? process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_TOKEN ?? process.env.UPSTASH_VECTOR_REST_TOKEN;\n    const url = configOrRequester?.url ?? process.env.NEXT_PUBLIC_UPSTASH_VECTOR_REST_URL ?? process.env.UPSTASH_VECTOR_REST_URL;\n    if (!token) {\n      throw new Error(\"UPSTASH_VECTOR_REST_TOKEN is missing!\");\n    }\n    if (!url) {\n      throw new Error(\"UPSTASH_VECTOR_REST_URL is missing!\");\n    }\n    if (url.startsWith(\" \") || url.endsWith(\" \") || /\\r|\\n/.test(url)) {\n      console.warn(\"The vector url contains whitespace or newline, which can cause errors!\");\n    }\n    if (token.startsWith(\" \") || token.endsWith(\" \") || /\\r|\\n/.test(token)) {\n      console.warn(\"The vector token contains whitespace or newline, which can cause errors!\");\n    }\n    const enableTelemetry = process.env.UPSTASH_DISABLE_TELEMETRY ? false : configOrRequester?.enableTelemetry ?? true;\n    const telemetryHeaders = enableTelemetry ? {\n      \"Upstash-Telemetry-Sdk\": `upstash-vector-js@${_chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION}`,\n      \"Upstash-Telemetry-Platform\": process.env.VERCEL ? \"vercel\" : process.env.AWS_REGION ? \"aws\" : \"unknown\",\n      \"Upstash-Telemetry-Runtime\": getRuntime()\n    } : {};\n    const client = new _chunk_HESEGT2A_mjs__WEBPACK_IMPORTED_MODULE_0__.HttpClient({\n      baseUrl: url,\n      retry: configOrRequester?.retry,\n      headers: { authorization: `Bearer ${token}`, ...telemetryHeaders },\n      cache: configOrRequester?.cache === false ? void 0 : configOrRequester?.cache || \"no-store\",\n      signal: configOrRequester?.signal\n    });\n    super(client);\n  }\n  /**\n   * Create a new Upstash Vector instance from environment variables.\n   *\n   * Use this to automatically load connection secrets from your environment\n   * variables. For instance when using the Vercel integration.\n   *\n   * When used on the Cloudflare Workers, you can just pass the \"env\" context provided by Cloudflare.\n   * Else, this tries to load `UPSTASH_VECTOR_REST_URL` and `UPSTASH_VECTOR_REST_TOKEN` from\n   * your environment using `process.env`.\n   */\n  static fromEnv(env, config) {\n    const url = env?.UPSTASH_VECTOR_REST_URL || process?.env.UPSTASH_VECTOR_REST_URL;\n    const token = env?.UPSTASH_VECTOR_REST_TOKEN || process?.env.UPSTASH_VECTOR_REST_TOKEN;\n    if (!url) {\n      throw new Error(\"Unable to find environment variable: `UPSTASH_VECTOR_REST_URL`\");\n    }\n    if (!token) {\n      throw new Error(\"Unable to find environment variable: `UPSTASH_VECTOR_REST_TOKEN`\");\n    }\n    return new _Index({ ...config, url, token });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHVwc3Rhc2gvdmVjdG9yL2Rpc3Qvbm9kZWpzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQU84Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxrRUFBa0UsZ0JBQWdCO0FBQ2xGOztBQUVBO0FBQ0Esa0NBQWtDLHNEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3REFBTyxDQUFDO0FBQzVEO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLDJEQUFVO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCLE1BQU0sd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBTUUiLCJzb3VyY2VzIjpbIi9ob21lL210YWhhc3lsbXovRGVza3RvcC91cHN0YXNoL21hc3RyYS93aXRoQXBpL25vZGVfbW9kdWxlcy9AdXBzdGFzaC92ZWN0b3IvZGlzdC9ub2RlanMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEZ1c2lvbkFsZ29yaXRobSxcbiAgSHR0cENsaWVudCxcbiAgSW5kZXgsXG4gIFF1ZXJ5TW9kZSxcbiAgVkVSU0lPTixcbiAgV2VpZ2h0aW5nU3RyYXRlZ3lcbn0gZnJvbSBcIi4vY2h1bmstSEVTRUdUMkEubWpzXCI7XG5cbi8vIHNyYy91dGlscy9nZXQtcnVudGltZS50c1xuZnVuY3Rpb24gZ2V0UnVudGltZSgpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgcHJvY2Vzcy52ZXJzaW9ucy5idW4pXG4gICAgcmV0dXJuIGBidW5AJHtwcm9jZXNzLnZlcnNpb25zLmJ1bn1gO1xuICByZXR1cm4gdHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiID8gXCJlZGdlLWxpZ2h0XCIgOiBgbm9kZUAke3Byb2Nlc3MudmVyc2lvbn1gO1xufVxuXG4vLyBzcmMvcGxhdGZvcm1zL25vZGVqcy50c1xudmFyIEluZGV4MiA9IGNsYXNzIF9JbmRleCBleHRlbmRzIEluZGV4IHtcbiAgY29uc3RydWN0b3IoY29uZmlnT3JSZXF1ZXN0ZXIpIHtcbiAgICBpZiAoY29uZmlnT3JSZXF1ZXN0ZXIgIT09IHZvaWQgMCAmJiBcInJlcXVlc3RcIiBpbiBjb25maWdPclJlcXVlc3Rlcikge1xuICAgICAgc3VwZXIoY29uZmlnT3JSZXF1ZXN0ZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IGNvbmZpZ09yUmVxdWVzdGVyPy50b2tlbiA/PyBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VUFNUQVNIX1ZFQ1RPUl9SRVNUX1RPS0VOID8/IHByb2Nlc3MuZW52LlVQU1RBU0hfVkVDVE9SX1JFU1RfVE9LRU47XG4gICAgY29uc3QgdXJsID0gY29uZmlnT3JSZXF1ZXN0ZXI/LnVybCA/PyBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VUFNUQVNIX1ZFQ1RPUl9SRVNUX1VSTCA/PyBwcm9jZXNzLmVudi5VUFNUQVNIX1ZFQ1RPUl9SRVNUX1VSTDtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUFNUQVNIX1ZFQ1RPUl9SRVNUX1RPS0VOIGlzIG1pc3NpbmchXCIpO1xuICAgIH1cbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVBTVEFTSF9WRUNUT1JfUkVTVF9VUkwgaXMgbWlzc2luZyFcIik7XG4gICAgfVxuICAgIGlmICh1cmwuc3RhcnRzV2l0aChcIiBcIikgfHwgdXJsLmVuZHNXaXRoKFwiIFwiKSB8fCAvXFxyfFxcbi8udGVzdCh1cmwpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUaGUgdmVjdG9yIHVybCBjb250YWlucyB3aGl0ZXNwYWNlIG9yIG5ld2xpbmUsIHdoaWNoIGNhbiBjYXVzZSBlcnJvcnMhXCIpO1xuICAgIH1cbiAgICBpZiAodG9rZW4uc3RhcnRzV2l0aChcIiBcIikgfHwgdG9rZW4uZW5kc1dpdGgoXCIgXCIpIHx8IC9cXHJ8XFxuLy50ZXN0KHRva2VuKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVGhlIHZlY3RvciB0b2tlbiBjb250YWlucyB3aGl0ZXNwYWNlIG9yIG5ld2xpbmUsIHdoaWNoIGNhbiBjYXVzZSBlcnJvcnMhXCIpO1xuICAgIH1cbiAgICBjb25zdCBlbmFibGVUZWxlbWV0cnkgPSBwcm9jZXNzLmVudi5VUFNUQVNIX0RJU0FCTEVfVEVMRU1FVFJZID8gZmFsc2UgOiBjb25maWdPclJlcXVlc3Rlcj8uZW5hYmxlVGVsZW1ldHJ5ID8/IHRydWU7XG4gICAgY29uc3QgdGVsZW1ldHJ5SGVhZGVycyA9IGVuYWJsZVRlbGVtZXRyeSA/IHtcbiAgICAgIFwiVXBzdGFzaC1UZWxlbWV0cnktU2RrXCI6IGB1cHN0YXNoLXZlY3Rvci1qc0Ake1ZFUlNJT059YCxcbiAgICAgIFwiVXBzdGFzaC1UZWxlbWV0cnktUGxhdGZvcm1cIjogcHJvY2Vzcy5lbnYuVkVSQ0VMID8gXCJ2ZXJjZWxcIiA6IHByb2Nlc3MuZW52LkFXU19SRUdJT04gPyBcImF3c1wiIDogXCJ1bmtub3duXCIsXG4gICAgICBcIlVwc3Rhc2gtVGVsZW1ldHJ5LVJ1bnRpbWVcIjogZ2V0UnVudGltZSgpXG4gICAgfSA6IHt9O1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHtcbiAgICAgIGJhc2VVcmw6IHVybCxcbiAgICAgIHJldHJ5OiBjb25maWdPclJlcXVlc3Rlcj8ucmV0cnksXG4gICAgICBoZWFkZXJzOiB7IGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLCAuLi50ZWxlbWV0cnlIZWFkZXJzIH0sXG4gICAgICBjYWNoZTogY29uZmlnT3JSZXF1ZXN0ZXI/LmNhY2hlID09PSBmYWxzZSA/IHZvaWQgMCA6IGNvbmZpZ09yUmVxdWVzdGVyPy5jYWNoZSB8fCBcIm5vLXN0b3JlXCIsXG4gICAgICBzaWduYWw6IGNvbmZpZ09yUmVxdWVzdGVyPy5zaWduYWxcbiAgICB9KTtcbiAgICBzdXBlcihjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgVXBzdGFzaCBWZWN0b3IgaW5zdGFuY2UgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAqXG4gICAqIFVzZSB0aGlzIHRvIGF1dG9tYXRpY2FsbHkgbG9hZCBjb25uZWN0aW9uIHNlY3JldHMgZnJvbSB5b3VyIGVudmlyb25tZW50XG4gICAqIHZhcmlhYmxlcy4gRm9yIGluc3RhbmNlIHdoZW4gdXNpbmcgdGhlIFZlcmNlbCBpbnRlZ3JhdGlvbi5cbiAgICpcbiAgICogV2hlbiB1c2VkIG9uIHRoZSBDbG91ZGZsYXJlIFdvcmtlcnMsIHlvdSBjYW4ganVzdCBwYXNzIHRoZSBcImVudlwiIGNvbnRleHQgcHJvdmlkZWQgYnkgQ2xvdWRmbGFyZS5cbiAgICogRWxzZSwgdGhpcyB0cmllcyB0byBsb2FkIGBVUFNUQVNIX1ZFQ1RPUl9SRVNUX1VSTGAgYW5kIGBVUFNUQVNIX1ZFQ1RPUl9SRVNUX1RPS0VOYCBmcm9tXG4gICAqIHlvdXIgZW52aXJvbm1lbnQgdXNpbmcgYHByb2Nlc3MuZW52YC5cbiAgICovXG4gIHN0YXRpYyBmcm9tRW52KGVudiwgY29uZmlnKSB7XG4gICAgY29uc3QgdXJsID0gZW52Py5VUFNUQVNIX1ZFQ1RPUl9SRVNUX1VSTCB8fCBwcm9jZXNzPy5lbnYuVVBTVEFTSF9WRUNUT1JfUkVTVF9VUkw7XG4gICAgY29uc3QgdG9rZW4gPSBlbnY/LlVQU1RBU0hfVkVDVE9SX1JFU1RfVE9LRU4gfHwgcHJvY2Vzcz8uZW52LlVQU1RBU0hfVkVDVE9SX1JFU1RfVE9LRU47XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGVudmlyb25tZW50IHZhcmlhYmxlOiBgVVBTVEFTSF9WRUNUT1JfUkVTVF9VUkxgXCIpO1xuICAgIH1cbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBlbnZpcm9ubWVudCB2YXJpYWJsZTogYFVQU1RBU0hfVkVDVE9SX1JFU1RfVE9LRU5gXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9JbmRleCh7IC4uLmNvbmZpZywgdXJsLCB0b2tlbiB9KTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEZ1c2lvbkFsZ29yaXRobSxcbiAgSW5kZXgyIGFzIEluZGV4LFxuICBRdWVyeU1vZGUsXG4gIFdlaWdodGluZ1N0cmF0ZWd5XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@upstash/vector/dist/nodejs.mjs\n");

/***/ })

};
;