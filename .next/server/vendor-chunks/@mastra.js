"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mastra";
exports.ids = ["vendor-chunks/@mastra"];
exports.modules = {

/***/ "(ssr)/./node_modules/@mastra/client-js/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mastra/client-js/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MastraClient: () => (/* binding */ MastraClient)\n/* harmony export */ });\n/* harmony import */ var _ag_ui_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ag-ui/client */ \"(ssr)/./node_modules/@ag-ui/client/dist/index.mjs\");\n/* harmony import */ var _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ag-ui/client */ \"(ssr)/./node_modules/@ag-ui/core/dist/index.mjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/cjs/index.js\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod-to-json-schema */ \"(ssr)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _mastra_core_runtime_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mastra/core/runtime-context */ \"(ssr)/./node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js\");\n\n\n\n\n\n\n\n// src/adapters/agui.ts\nvar AGUIAdapter = class extends _ag_ui_client__WEBPACK_IMPORTED_MODULE_1__.AbstractAgent {\n  agent;\n  resourceId;\n  constructor({ agent, agentId, resourceId, ...rest }) {\n    super({\n      agentId,\n      ...rest\n    });\n    this.agent = agent;\n    this.resourceId = resourceId;\n  }\n  run(input) {\n    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((subscriber) => {\n      const convertedMessages = convertMessagesToMastraMessages(input.messages);\n      subscriber.next({\n        type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.RUN_STARTED,\n        threadId: input.threadId,\n        runId: input.runId\n      });\n      this.agent.stream({\n        threadId: input.threadId,\n        resourceId: this.resourceId ?? \"\",\n        runId: input.runId,\n        messages: convertedMessages,\n        clientTools: input.tools.reduce(\n          (acc, tool) => {\n            acc[tool.name] = {\n              id: tool.name,\n              description: tool.description,\n              inputSchema: tool.parameters\n            };\n            return acc;\n          },\n          {}\n        )\n      }).then((response) => {\n        let currentMessageId = void 0;\n        let isInTextMessage = false;\n        return response.processDataStream({\n          onTextPart: (text) => {\n            if (currentMessageId === void 0) {\n              currentMessageId = generateUUID();\n              const message2 = {\n                type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TEXT_MESSAGE_START,\n                messageId: currentMessageId,\n                role: \"assistant\"\n              };\n              subscriber.next(message2);\n              isInTextMessage = true;\n            }\n            const message = {\n              type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TEXT_MESSAGE_CONTENT,\n              messageId: currentMessageId,\n              delta: text\n            };\n            subscriber.next(message);\n          },\n          onFinishMessagePart: () => {\n            if (currentMessageId !== void 0) {\n              const message = {\n                type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TEXT_MESSAGE_END,\n                messageId: currentMessageId\n              };\n              subscriber.next(message);\n              isInTextMessage = false;\n            }\n            subscriber.next({\n              type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.RUN_FINISHED,\n              threadId: input.threadId,\n              runId: input.runId\n            });\n            subscriber.complete();\n          },\n          onToolCallPart(streamPart) {\n            const parentMessageId = currentMessageId || generateUUID();\n            if (isInTextMessage) {\n              const message = {\n                type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TEXT_MESSAGE_END,\n                messageId: parentMessageId\n              };\n              subscriber.next(message);\n              isInTextMessage = false;\n            }\n            subscriber.next({\n              type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TOOL_CALL_START,\n              toolCallId: streamPart.toolCallId,\n              toolCallName: streamPart.toolName,\n              parentMessageId\n            });\n            subscriber.next({\n              type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TOOL_CALL_ARGS,\n              toolCallId: streamPart.toolCallId,\n              delta: JSON.stringify(streamPart.args),\n              parentMessageId\n            });\n            subscriber.next({\n              type: _ag_ui_client__WEBPACK_IMPORTED_MODULE_3__.EventType.TOOL_CALL_END,\n              toolCallId: streamPart.toolCallId,\n              parentMessageId\n            });\n          }\n        });\n      }).catch((error) => {\n        console.error(\"error\", error);\n        subscriber.error(error);\n      });\n      return () => {\n      };\n    });\n  }\n};\nfunction generateUUID() {\n  if (typeof crypto !== \"undefined\") {\n    if (typeof crypto.randomUUID === \"function\") {\n      return crypto.randomUUID();\n    }\n    if (typeof crypto.getRandomValues === \"function\") {\n      const buffer = new Uint8Array(16);\n      crypto.getRandomValues(buffer);\n      buffer[6] = buffer[6] & 15 | 64;\n      buffer[8] = buffer[8] & 63 | 128;\n      let hex = \"\";\n      for (let i = 0; i < 16; i++) {\n        hex += buffer[i].toString(16).padStart(2, \"0\");\n        if (i === 3 || i === 5 || i === 7 || i === 9) hex += \"-\";\n      }\n      return hex;\n    }\n  }\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = Math.random() * 16 | 0;\n    const v = c === \"x\" ? r : r & 3 | 8;\n    return v.toString(16);\n  });\n}\nfunction convertMessagesToMastraMessages(messages) {\n  const result = [];\n  for (const message of messages) {\n    if (message.role === \"assistant\") {\n      const parts = message.content ? [{ type: \"text\", text: message.content }] : [];\n      for (const toolCall of message.toolCalls ?? []) {\n        parts.push({\n          type: \"tool-call\",\n          toolCallId: toolCall.id,\n          toolName: toolCall.function.name,\n          args: JSON.parse(toolCall.function.arguments)\n        });\n      }\n      result.push({\n        role: \"assistant\",\n        content: parts\n      });\n      if (message.toolCalls?.length) {\n        result.push({\n          role: \"tool\",\n          content: message.toolCalls.map((toolCall) => ({\n            type: \"tool-result\",\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            result: JSON.parse(toolCall.function.arguments)\n          }))\n        });\n      }\n    } else if (message.role === \"user\") {\n      result.push({\n        role: \"user\",\n        content: message.content || \"\"\n      });\n    } else if (message.role === \"tool\") {\n      result.push({\n        role: \"tool\",\n        content: [\n          {\n            type: \"tool-result\",\n            toolCallId: message.toolCallId,\n            toolName: \"unknown\",\n            result: message.content\n          }\n        ]\n      });\n    }\n  }\n  return result;\n}\nfunction zodToJsonSchema(zodSchema) {\n  if (!(zodSchema instanceof zod__WEBPACK_IMPORTED_MODULE_4__.ZodSchema)) {\n    return zodSchema;\n  }\n  return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zodSchema, { $refStrategy: \"none\" });\n}\n\n// src/resources/base.ts\nvar BaseResource = class {\n  options;\n  constructor(options) {\n    this.options = options;\n  }\n  /**\n   * Makes an HTTP request to the API with retries and exponential backoff\n   * @param path - The API endpoint path\n   * @param options - Optional request configuration\n   * @returns Promise containing the response data\n   */\n  async request(path, options = {}) {\n    let lastError = null;\n    const { baseUrl, retries = 3, backoffMs = 100, maxBackoffMs = 1e3, headers = {} } = this.options;\n    let delay = backoffMs;\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const response = await fetch(`${baseUrl.replace(/\\/$/, \"\")}${path}`, {\n          ...options,\n          headers: {\n            ...headers,\n            ...options.headers\n            // TODO: Bring this back once we figure out what we/users need to do to make this work with cross-origin requests\n            // 'x-mastra-client-type': 'js',\n          },\n          body: options.body instanceof FormData ? options.body : options.body ? JSON.stringify(options.body) : void 0\n        });\n        if (!response.ok) {\n          const errorBody = await response.text();\n          let errorMessage = `HTTP error! status: ${response.status}`;\n          try {\n            const errorJson = JSON.parse(errorBody);\n            errorMessage += ` - ${JSON.stringify(errorJson)}`;\n          } catch {\n            if (errorBody) {\n              errorMessage += ` - ${errorBody}`;\n            }\n          }\n          throw new Error(errorMessage);\n        }\n        if (options.stream) {\n          return response;\n        }\n        const data = await response.json();\n        return data;\n      } catch (error) {\n        lastError = error;\n        if (attempt === retries) {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay = Math.min(delay * 2, maxBackoffMs);\n      }\n    }\n    throw lastError || new Error(\"Request failed\");\n  }\n};\nfunction parseClientRuntimeContext(runtimeContext) {\n  if (runtimeContext) {\n    if (runtimeContext instanceof _mastra_core_runtime_context__WEBPACK_IMPORTED_MODULE_5__.RuntimeContext) {\n      return Object.fromEntries(runtimeContext.entries());\n    }\n    return runtimeContext;\n  }\n  return void 0;\n}\n\n// src/resources/agent.ts\nvar AgentVoice = class extends BaseResource {\n  constructor(options, agentId) {\n    super(options);\n    this.agentId = agentId;\n    this.agentId = agentId;\n  }\n  /**\n   * Convert text to speech using the agent's voice provider\n   * @param text - Text to convert to speech\n   * @param options - Optional provider-specific options for speech generation\n   * @returns Promise containing the audio data\n   */\n  async speak(text, options) {\n    return this.request(`/api/agents/${this.agentId}/voice/speak`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: { input: text, options },\n      stream: true\n    });\n  }\n  /**\n   * Convert speech to text using the agent's voice provider\n   * @param audio - Audio data to transcribe\n   * @param options - Optional provider-specific options\n   * @returns Promise containing the transcribed text\n   */\n  listen(audio, options) {\n    const formData = new FormData();\n    formData.append(\"audio\", audio);\n    if (options) {\n      formData.append(\"options\", JSON.stringify(options));\n    }\n    return this.request(`/api/agents/${this.agentId}/voice/listen`, {\n      method: \"POST\",\n      body: formData\n    });\n  }\n  /**\n   * Get available speakers for the agent's voice provider\n   * @returns Promise containing list of available speakers\n   */\n  getSpeakers() {\n    return this.request(`/api/agents/${this.agentId}/voice/speakers`);\n  }\n};\nvar Agent = class extends BaseResource {\n  constructor(options, agentId) {\n    super(options);\n    this.agentId = agentId;\n    this.voice = new AgentVoice(options, this.agentId);\n  }\n  voice;\n  /**\n   * Retrieves details about the agent\n   * @returns Promise containing agent details including model and instructions\n   */\n  details() {\n    return this.request(`/api/agents/${this.agentId}`);\n  }\n  /**\n   * Generates a response from the agent\n   * @param params - Generation parameters including prompt\n   * @returns Promise containing the generated response\n   */\n  generate(params) {\n    const processedParams = {\n      ...params,\n      output: params.output ? zodToJsonSchema(params.output) : void 0,\n      experimental_output: params.experimental_output ? zodToJsonSchema(params.experimental_output) : void 0,\n      runtimeContext: parseClientRuntimeContext(params.runtimeContext)\n    };\n    return this.request(`/api/agents/${this.agentId}/generate`, {\n      method: \"POST\",\n      body: processedParams\n    });\n  }\n  /**\n   * Streams a response from the agent\n   * @param params - Stream parameters including prompt\n   * @returns Promise containing the enhanced Response object with processDataStream method\n   */\n  async stream(params) {\n    const processedParams = {\n      ...params,\n      output: params.output ? zodToJsonSchema(params.output) : void 0,\n      experimental_output: params.experimental_output ? zodToJsonSchema(params.experimental_output) : void 0,\n      runtimeContext: parseClientRuntimeContext(params.runtimeContext)\n    };\n    const response = await this.request(`/api/agents/${this.agentId}/stream`, {\n      method: \"POST\",\n      body: processedParams,\n      stream: true\n    });\n    if (!response.body) {\n      throw new Error(\"No response body\");\n    }\n    response.processDataStream = async (options = {}) => {\n      await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__.processDataStream)({\n        stream: response.body,\n        ...options\n      });\n    };\n    return response;\n  }\n  /**\n   * Gets details about a specific tool available to the agent\n   * @param toolId - ID of the tool to retrieve\n   * @returns Promise containing tool details\n   */\n  getTool(toolId) {\n    return this.request(`/api/agents/${this.agentId}/tools/${toolId}`);\n  }\n  /**\n   * Executes a tool for the agent\n   * @param toolId - ID of the tool to execute\n   * @param params - Parameters required for tool execution\n   * @returns Promise containing the tool execution results\n   */\n  executeTool(toolId, params) {\n    const body = {\n      data: params.data,\n      runtimeContext: params.runtimeContext ? Object.fromEntries(params.runtimeContext.entries()) : void 0\n    };\n    return this.request(`/api/agents/${this.agentId}/tools/${toolId}/execute`, {\n      method: \"POST\",\n      body\n    });\n  }\n  /**\n   * Retrieves evaluation results for the agent\n   * @returns Promise containing agent evaluations\n   */\n  evals() {\n    return this.request(`/api/agents/${this.agentId}/evals/ci`);\n  }\n  /**\n   * Retrieves live evaluation results for the agent\n   * @returns Promise containing live agent evaluations\n   */\n  liveEvals() {\n    return this.request(`/api/agents/${this.agentId}/evals/live`);\n  }\n};\nvar Network = class extends BaseResource {\n  constructor(options, networkId) {\n    super(options);\n    this.networkId = networkId;\n  }\n  /**\n   * Retrieves details about the network\n   * @returns Promise containing network details\n   */\n  details() {\n    return this.request(`/api/networks/${this.networkId}`);\n  }\n  /**\n   * Generates a response from the agent\n   * @param params - Generation parameters including prompt\n   * @returns Promise containing the generated response\n   */\n  generate(params) {\n    const processedParams = {\n      ...params,\n      output: zodToJsonSchema(params.output),\n      experimental_output: zodToJsonSchema(params.experimental_output)\n    };\n    return this.request(`/api/networks/${this.networkId}/generate`, {\n      method: \"POST\",\n      body: processedParams\n    });\n  }\n  /**\n   * Streams a response from the agent\n   * @param params - Stream parameters including prompt\n   * @returns Promise containing the enhanced Response object with processDataStream method\n   */\n  async stream(params) {\n    const processedParams = {\n      ...params,\n      output: zodToJsonSchema(params.output),\n      experimental_output: zodToJsonSchema(params.experimental_output)\n    };\n    const response = await this.request(`/api/networks/${this.networkId}/stream`, {\n      method: \"POST\",\n      body: processedParams,\n      stream: true\n    });\n    if (!response.body) {\n      throw new Error(\"No response body\");\n    }\n    response.processDataStream = async (options = {}) => {\n      await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_6__.processDataStream)({\n        stream: response.body,\n        ...options\n      });\n    };\n    return response;\n  }\n};\n\n// src/resources/memory-thread.ts\nvar MemoryThread = class extends BaseResource {\n  constructor(options, threadId, agentId) {\n    super(options);\n    this.threadId = threadId;\n    this.agentId = agentId;\n  }\n  /**\n   * Retrieves the memory thread details\n   * @returns Promise containing thread details including title and metadata\n   */\n  get() {\n    return this.request(`/api/memory/threads/${this.threadId}?agentId=${this.agentId}`);\n  }\n  /**\n   * Updates the memory thread properties\n   * @param params - Update parameters including title and metadata\n   * @returns Promise containing updated thread details\n   */\n  update(params) {\n    return this.request(`/api/memory/threads/${this.threadId}?agentId=${this.agentId}`, {\n      method: \"PATCH\",\n      body: params\n    });\n  }\n  /**\n   * Deletes the memory thread\n   * @returns Promise containing deletion result\n   */\n  delete() {\n    return this.request(`/api/memory/threads/${this.threadId}?agentId=${this.agentId}`, {\n      method: \"DELETE\"\n    });\n  }\n  /**\n   * Retrieves messages associated with the thread\n   * @param params - Optional parameters including limit for number of messages to retrieve\n   * @returns Promise containing thread messages and UI messages\n   */\n  getMessages(params) {\n    const query = new URLSearchParams({\n      agentId: this.agentId,\n      ...params?.limit ? { limit: params.limit.toString() } : {}\n    });\n    return this.request(`/api/memory/threads/${this.threadId}/messages?${query.toString()}`);\n  }\n};\n\n// src/resources/vector.ts\nvar Vector = class extends BaseResource {\n  constructor(options, vectorName) {\n    super(options);\n    this.vectorName = vectorName;\n  }\n  /**\n   * Retrieves details about a specific vector index\n   * @param indexName - Name of the index to get details for\n   * @returns Promise containing vector index details\n   */\n  details(indexName) {\n    return this.request(`/api/vector/${this.vectorName}/indexes/${indexName}`);\n  }\n  /**\n   * Deletes a vector index\n   * @param indexName - Name of the index to delete\n   * @returns Promise indicating deletion success\n   */\n  delete(indexName) {\n    return this.request(`/api/vector/${this.vectorName}/indexes/${indexName}`, {\n      method: \"DELETE\"\n    });\n  }\n  /**\n   * Retrieves a list of all available indexes\n   * @returns Promise containing array of index names\n   */\n  getIndexes() {\n    return this.request(`/api/vector/${this.vectorName}/indexes`);\n  }\n  /**\n   * Creates a new vector index\n   * @param params - Parameters for index creation including dimension and metric\n   * @returns Promise indicating creation success\n   */\n  createIndex(params) {\n    return this.request(`/api/vector/${this.vectorName}/create-index`, {\n      method: \"POST\",\n      body: params\n    });\n  }\n  /**\n   * Upserts vectors into an index\n   * @param params - Parameters containing vectors, metadata, and optional IDs\n   * @returns Promise containing array of vector IDs\n   */\n  upsert(params) {\n    return this.request(`/api/vector/${this.vectorName}/upsert`, {\n      method: \"POST\",\n      body: params\n    });\n  }\n  /**\n   * Queries vectors in an index\n   * @param params - Query parameters including query vector and search options\n   * @returns Promise containing query results\n   */\n  query(params) {\n    return this.request(`/api/vector/${this.vectorName}/query`, {\n      method: \"POST\",\n      body: params\n    });\n  }\n};\n\n// src/resources/legacy-workflow.ts\nvar RECORD_SEPARATOR = \"\u001e\";\nvar LegacyWorkflow = class extends BaseResource {\n  constructor(options, workflowId) {\n    super(options);\n    this.workflowId = workflowId;\n  }\n  /**\n   * Retrieves details about the legacy workflow\n   * @returns Promise containing legacy workflow details including steps and graphs\n   */\n  details() {\n    return this.request(`/api/workflows/legacy/${this.workflowId}`);\n  }\n  /**\n   * Retrieves all runs for a legacy workflow\n   * @param params - Parameters for filtering runs\n   * @returns Promise containing legacy workflow runs array\n   */\n  runs(params) {\n    const searchParams = new URLSearchParams();\n    if (params?.fromDate) {\n      searchParams.set(\"fromDate\", params.fromDate.toISOString());\n    }\n    if (params?.toDate) {\n      searchParams.set(\"toDate\", params.toDate.toISOString());\n    }\n    if (params?.limit) {\n      searchParams.set(\"limit\", String(params.limit));\n    }\n    if (params?.offset) {\n      searchParams.set(\"offset\", String(params.offset));\n    }\n    if (params?.resourceId) {\n      searchParams.set(\"resourceId\", params.resourceId);\n    }\n    if (searchParams.size) {\n      return this.request(`/api/workflows/legacy/${this.workflowId}/runs?${searchParams}`);\n    } else {\n      return this.request(`/api/workflows/legacy/${this.workflowId}/runs`);\n    }\n  }\n  /**\n   * Creates a new legacy workflow run\n   * @returns Promise containing the generated run ID\n   */\n  createRun(params) {\n    const searchParams = new URLSearchParams();\n    if (!!params?.runId) {\n      searchParams.set(\"runId\", params.runId);\n    }\n    return this.request(`/api/workflows/legacy/${this.workflowId}/create-run?${searchParams.toString()}`, {\n      method: \"POST\"\n    });\n  }\n  /**\n   * Starts a legacy workflow run synchronously without waiting for the workflow to complete\n   * @param params - Object containing the runId and triggerData\n   * @returns Promise containing success message\n   */\n  start(params) {\n    return this.request(`/api/workflows/legacy/${this.workflowId}/start?runId=${params.runId}`, {\n      method: \"POST\",\n      body: params?.triggerData\n    });\n  }\n  /**\n   * Resumes a suspended legacy workflow step synchronously without waiting for the workflow to complete\n   * @param stepId - ID of the step to resume\n   * @param runId - ID of the legacy workflow run\n   * @param context - Context to resume the legacy workflow with\n   * @returns Promise containing the legacy workflow resume results\n   */\n  resume({\n    stepId,\n    runId,\n    context\n  }) {\n    return this.request(`/api/workflows/legacy/${this.workflowId}/resume?runId=${runId}`, {\n      method: \"POST\",\n      body: {\n        stepId,\n        context\n      }\n    });\n  }\n  /**\n   * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the optional runId and triggerData\n   * @returns Promise containing the workflow execution results\n   */\n  startAsync(params) {\n    const searchParams = new URLSearchParams();\n    if (!!params?.runId) {\n      searchParams.set(\"runId\", params.runId);\n    }\n    return this.request(`/api/workflows/legacy/${this.workflowId}/start-async?${searchParams.toString()}`, {\n      method: \"POST\",\n      body: params?.triggerData\n    });\n  }\n  /**\n   * Resumes a suspended legacy workflow step asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the runId, stepId, and context\n   * @returns Promise containing the workflow resume results\n   */\n  resumeAsync(params) {\n    return this.request(`/api/workflows/legacy/${this.workflowId}/resume-async?runId=${params.runId}`, {\n      method: \"POST\",\n      body: {\n        stepId: params.stepId,\n        context: params.context\n      }\n    });\n  }\n  /**\n   * Creates an async generator that processes a readable stream and yields records\n   * separated by the Record Separator character (\\x1E)\n   *\n   * @param stream - The readable stream to process\n   * @returns An async generator that yields parsed records\n   */\n  async *streamProcessor(stream) {\n    const reader = stream.getReader();\n    let doneReading = false;\n    let buffer = \"\";\n    try {\n      while (!doneReading) {\n        const { done, value } = await reader.read();\n        doneReading = done;\n        if (done && !value) continue;\n        try {\n          const decoded = value ? new TextDecoder().decode(value) : \"\";\n          const chunks = (buffer + decoded).split(RECORD_SEPARATOR);\n          buffer = chunks.pop() || \"\";\n          for (const chunk of chunks) {\n            if (chunk) {\n              if (typeof chunk === \"string\") {\n                try {\n                  const parsedChunk = JSON.parse(chunk);\n                  yield parsedChunk;\n                } catch {\n                }\n              }\n            }\n          }\n        } catch {\n        }\n      }\n      if (buffer) {\n        try {\n          yield JSON.parse(buffer);\n        } catch {\n        }\n      }\n    } finally {\n      reader.cancel().catch(() => {\n      });\n    }\n  }\n  /**\n   * Watches legacy workflow transitions in real-time\n   * @param runId - Optional run ID to filter the watch stream\n   * @returns AsyncGenerator that yields parsed records from the legacy workflow watch stream\n   */\n  async watch({ runId }, onRecord) {\n    const response = await this.request(`/api/workflows/legacy/${this.workflowId}/watch?runId=${runId}`, {\n      stream: true\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to watch legacy workflow: ${response.statusText}`);\n    }\n    if (!response.body) {\n      throw new Error(\"Response body is null\");\n    }\n    for await (const record of this.streamProcessor(response.body)) {\n      onRecord(record);\n    }\n  }\n};\n\n// src/resources/tool.ts\nvar Tool = class extends BaseResource {\n  constructor(options, toolId) {\n    super(options);\n    this.toolId = toolId;\n  }\n  /**\n   * Retrieves details about the tool\n   * @returns Promise containing tool details including description and schemas\n   */\n  details() {\n    return this.request(`/api/tools/${this.toolId}`);\n  }\n  /**\n   * Executes the tool with the provided parameters\n   * @param params - Parameters required for tool execution\n   * @returns Promise containing the tool execution results\n   */\n  execute(params) {\n    const url = new URLSearchParams();\n    if (params.runId) {\n      url.set(\"runId\", params.runId);\n    }\n    const body = {\n      data: params.data,\n      runtimeContext: parseClientRuntimeContext(params.runtimeContext)\n    };\n    return this.request(`/api/tools/${this.toolId}/execute?${url.toString()}`, {\n      method: \"POST\",\n      body\n    });\n  }\n};\n\n// src/resources/workflow.ts\nvar RECORD_SEPARATOR2 = \"\u001e\";\nvar Workflow = class extends BaseResource {\n  constructor(options, workflowId) {\n    super(options);\n    this.workflowId = workflowId;\n  }\n  /**\n   * Creates an async generator that processes a readable stream and yields workflow records\n   * separated by the Record Separator character (\\x1E)\n   *\n   * @param stream - The readable stream to process\n   * @returns An async generator that yields parsed records\n   */\n  async *streamProcessor(stream) {\n    const reader = stream.getReader();\n    let doneReading = false;\n    let buffer = \"\";\n    try {\n      while (!doneReading) {\n        const { done, value } = await reader.read();\n        doneReading = done;\n        if (done && !value) continue;\n        try {\n          const decoded = value ? new TextDecoder().decode(value) : \"\";\n          const chunks = (buffer + decoded).split(RECORD_SEPARATOR2);\n          buffer = chunks.pop() || \"\";\n          for (const chunk of chunks) {\n            if (chunk) {\n              if (typeof chunk === \"string\") {\n                try {\n                  const parsedChunk = JSON.parse(chunk);\n                  yield parsedChunk;\n                } catch {\n                }\n              }\n            }\n          }\n        } catch {\n        }\n      }\n      if (buffer) {\n        try {\n          yield JSON.parse(buffer);\n        } catch {\n        }\n      }\n    } finally {\n      reader.cancel().catch(() => {\n      });\n    }\n  }\n  /**\n   * Retrieves details about the workflow\n   * @returns Promise containing workflow details including steps and graphs\n   */\n  details() {\n    return this.request(`/api/workflows/${this.workflowId}`);\n  }\n  /**\n   * Retrieves all runs for a workflow\n   * @param params - Parameters for filtering runs\n   * @returns Promise containing workflow runs array\n   */\n  runs(params) {\n    const searchParams = new URLSearchParams();\n    if (params?.fromDate) {\n      searchParams.set(\"fromDate\", params.fromDate.toISOString());\n    }\n    if (params?.toDate) {\n      searchParams.set(\"toDate\", params.toDate.toISOString());\n    }\n    if (params?.limit) {\n      searchParams.set(\"limit\", String(params.limit));\n    }\n    if (params?.offset) {\n      searchParams.set(\"offset\", String(params.offset));\n    }\n    if (params?.resourceId) {\n      searchParams.set(\"resourceId\", params.resourceId);\n    }\n    if (searchParams.size) {\n      return this.request(`/api/workflows/${this.workflowId}/runs?${searchParams}`);\n    } else {\n      return this.request(`/api/workflows/${this.workflowId}/runs`);\n    }\n  }\n  /**\n   * Creates a new workflow run\n   * @param params - Optional object containing the optional runId\n   * @returns Promise containing the runId of the created run\n   */\n  createRun(params) {\n    const searchParams = new URLSearchParams();\n    if (!!params?.runId) {\n      searchParams.set(\"runId\", params.runId);\n    }\n    return this.request(`/api/workflows/${this.workflowId}/create-run?${searchParams.toString()}`, {\n      method: \"POST\"\n    });\n  }\n  /**\n   * Starts a workflow run synchronously without waiting for the workflow to complete\n   * @param params - Object containing the runId, inputData and runtimeContext\n   * @returns Promise containing success message\n   */\n  start(params) {\n    const runtimeContext = parseClientRuntimeContext(params.runtimeContext);\n    return this.request(`/api/workflows/${this.workflowId}/start?runId=${params.runId}`, {\n      method: \"POST\",\n      body: { inputData: params?.inputData, runtimeContext }\n    });\n  }\n  /**\n   * Resumes a suspended workflow step synchronously without waiting for the workflow to complete\n   * @param params - Object containing the runId, step, resumeData and runtimeContext\n   * @returns Promise containing success message\n   */\n  resume({\n    step,\n    runId,\n    resumeData,\n    ...rest\n  }) {\n    const runtimeContext = parseClientRuntimeContext(rest.runtimeContext);\n    return this.request(`/api/workflows/${this.workflowId}/resume?runId=${runId}`, {\n      method: \"POST\",\n      stream: true,\n      body: {\n        step,\n        resumeData,\n        runtimeContext\n      }\n    });\n  }\n  /**\n   * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the optional runId, inputData and runtimeContext\n   * @returns Promise containing the workflow execution results\n   */\n  startAsync(params) {\n    const searchParams = new URLSearchParams();\n    if (!!params?.runId) {\n      searchParams.set(\"runId\", params.runId);\n    }\n    const runtimeContext = parseClientRuntimeContext(params.runtimeContext);\n    return this.request(`/api/workflows/${this.workflowId}/start-async?${searchParams.toString()}`, {\n      method: \"POST\",\n      body: { inputData: params.inputData, runtimeContext }\n    });\n  }\n  /**\n   * Resumes a suspended workflow step asynchronously and returns a promise that resolves when the workflow is complete\n   * @param params - Object containing the runId, step, resumeData and runtimeContext\n   * @returns Promise containing the workflow resume results\n   */\n  resumeAsync(params) {\n    const runtimeContext = parseClientRuntimeContext(params.runtimeContext);\n    return this.request(`/api/workflows/${this.workflowId}/resume-async?runId=${params.runId}`, {\n      method: \"POST\",\n      body: {\n        step: params.step,\n        resumeData: params.resumeData,\n        runtimeContext\n      }\n    });\n  }\n  /**\n   * Watches workflow transitions in real-time\n   * @param runId - Optional run ID to filter the watch stream\n   * @returns AsyncGenerator that yields parsed records from the workflow watch stream\n   */\n  async watch({ runId }, onRecord) {\n    const response = await this.request(`/api/workflows/${this.workflowId}/watch?runId=${runId}`, {\n      stream: true\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to watch workflow: ${response.statusText}`);\n    }\n    if (!response.body) {\n      throw new Error(\"Response body is null\");\n    }\n    for await (const record of this.streamProcessor(response.body)) {\n      onRecord(record);\n    }\n  }\n};\n\n// src/resources/a2a.ts\nvar A2A = class extends BaseResource {\n  constructor(options, agentId) {\n    super(options);\n    this.agentId = agentId;\n  }\n  /**\n   * Get the agent card with metadata about the agent\n   * @returns Promise containing the agent card information\n   */\n  async getCard() {\n    return this.request(`/.well-known/${this.agentId}/agent.json`);\n  }\n  /**\n   * Send a message to the agent and get a response\n   * @param params - Parameters for the task\n   * @returns Promise containing the task response\n   */\n  async sendMessage(params) {\n    const response = await this.request(`/a2a/${this.agentId}`, {\n      method: \"POST\",\n      body: {\n        method: \"tasks/send\",\n        params\n      }\n    });\n    return { task: response.result };\n  }\n  /**\n   * Get the status and result of a task\n   * @param params - Parameters for querying the task\n   * @returns Promise containing the task response\n   */\n  async getTask(params) {\n    const response = await this.request(`/a2a/${this.agentId}`, {\n      method: \"POST\",\n      body: {\n        method: \"tasks/get\",\n        params\n      }\n    });\n    return response.result;\n  }\n  /**\n   * Cancel a running task\n   * @param params - Parameters identifying the task to cancel\n   * @returns Promise containing the task response\n   */\n  async cancelTask(params) {\n    return this.request(`/a2a/${this.agentId}`, {\n      method: \"POST\",\n      body: {\n        method: \"tasks/cancel\",\n        params\n      }\n    });\n  }\n  /**\n   * Send a message and subscribe to streaming updates (not fully implemented)\n   * @param params - Parameters for the task\n   * @returns Promise containing the task response\n   */\n  async sendAndSubscribe(params) {\n    return this.request(`/a2a/${this.agentId}`, {\n      method: \"POST\",\n      body: {\n        method: \"tasks/sendSubscribe\",\n        params\n      },\n      stream: true\n    });\n  }\n};\n\n// src/resources/mcp-tool.ts\nvar MCPTool = class extends BaseResource {\n  serverId;\n  toolId;\n  constructor(options, serverId, toolId) {\n    super(options);\n    this.serverId = serverId;\n    this.toolId = toolId;\n  }\n  /**\n   * Retrieves details about this specific tool from the MCP server.\n   * @returns Promise containing the tool's information (name, description, schema).\n   */\n  details() {\n    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}`);\n  }\n  /**\n   * Executes this specific tool on the MCP server.\n   * @param params - Parameters for tool execution, including data/args and optional runtimeContext.\n   * @returns Promise containing the result of the tool execution.\n   */\n  execute(params) {\n    const body = {};\n    if (params.data !== void 0) body.data = params.data;\n    if (params.runtimeContext !== void 0) {\n      body.runtimeContext = params.runtimeContext;\n    }\n    return this.request(`/api/mcp/${this.serverId}/tools/${this.toolId}/execute`, {\n      method: \"POST\",\n      body: Object.keys(body).length > 0 ? body : void 0\n    });\n  }\n};\n\n// src/client.ts\nvar MastraClient = class extends BaseResource {\n  constructor(options) {\n    super(options);\n  }\n  /**\n   * Retrieves all available agents\n   * @returns Promise containing map of agent IDs to agent details\n   */\n  getAgents() {\n    return this.request(\"/api/agents\");\n  }\n  async getAGUI({ resourceId }) {\n    const agents = await this.getAgents();\n    return Object.entries(agents).reduce(\n      (acc, [agentId]) => {\n        const agent = this.getAgent(agentId);\n        acc[agentId] = new AGUIAdapter({\n          agentId,\n          agent,\n          resourceId\n        });\n        return acc;\n      },\n      {}\n    );\n  }\n  /**\n   * Gets an agent instance by ID\n   * @param agentId - ID of the agent to retrieve\n   * @returns Agent instance\n   */\n  getAgent(agentId) {\n    return new Agent(this.options, agentId);\n  }\n  /**\n   * Retrieves memory threads for a resource\n   * @param params - Parameters containing the resource ID\n   * @returns Promise containing array of memory threads\n   */\n  getMemoryThreads(params) {\n    return this.request(`/api/memory/threads?resourceid=${params.resourceId}&agentId=${params.agentId}`);\n  }\n  /**\n   * Creates a new memory thread\n   * @param params - Parameters for creating the memory thread\n   * @returns Promise containing the created memory thread\n   */\n  createMemoryThread(params) {\n    return this.request(`/api/memory/threads?agentId=${params.agentId}`, { method: \"POST\", body: params });\n  }\n  /**\n   * Gets a memory thread instance by ID\n   * @param threadId - ID of the memory thread to retrieve\n   * @returns MemoryThread instance\n   */\n  getMemoryThread(threadId, agentId) {\n    return new MemoryThread(this.options, threadId, agentId);\n  }\n  /**\n   * Saves messages to memory\n   * @param params - Parameters containing messages to save\n   * @returns Promise containing the saved messages\n   */\n  saveMessageToMemory(params) {\n    return this.request(`/api/memory/save-messages?agentId=${params.agentId}`, {\n      method: \"POST\",\n      body: params\n    });\n  }\n  /**\n   * Gets the status of the memory system\n   * @returns Promise containing memory system status\n   */\n  getMemoryStatus(agentId) {\n    return this.request(`/api/memory/status?agentId=${agentId}`);\n  }\n  /**\n   * Retrieves all available tools\n   * @returns Promise containing map of tool IDs to tool details\n   */\n  getTools() {\n    return this.request(\"/api/tools\");\n  }\n  /**\n   * Gets a tool instance by ID\n   * @param toolId - ID of the tool to retrieve\n   * @returns Tool instance\n   */\n  getTool(toolId) {\n    return new Tool(this.options, toolId);\n  }\n  /**\n   * Retrieves all available legacy workflows\n   * @returns Promise containing map of legacy workflow IDs to legacy workflow details\n   */\n  getLegacyWorkflows() {\n    return this.request(\"/api/workflows/legacy\");\n  }\n  /**\n   * Gets a legacy workflow instance by ID\n   * @param workflowId - ID of the legacy workflow to retrieve\n   * @returns Legacy Workflow instance\n   */\n  getLegacyWorkflow(workflowId) {\n    return new LegacyWorkflow(this.options, workflowId);\n  }\n  /**\n   * Retrieves all available workflows\n   * @returns Promise containing map of workflow IDs to workflow details\n   */\n  getWorkflows() {\n    return this.request(\"/api/workflows\");\n  }\n  /**\n   * Gets a workflow instance by ID\n   * @param workflowId - ID of the workflow to retrieve\n   * @returns Workflow instance\n   */\n  getWorkflow(workflowId) {\n    return new Workflow(this.options, workflowId);\n  }\n  /**\n   * Gets a vector instance by name\n   * @param vectorName - Name of the vector to retrieve\n   * @returns Vector instance\n   */\n  getVector(vectorName) {\n    return new Vector(this.options, vectorName);\n  }\n  /**\n   * Retrieves logs\n   * @param params - Parameters for filtering logs\n   * @returns Promise containing array of log messages\n   */\n  getLogs(params) {\n    return this.request(`/api/logs?transportId=${params.transportId}`);\n  }\n  /**\n   * Gets logs for a specific run\n   * @param params - Parameters containing run ID to retrieve\n   * @returns Promise containing array of log messages\n   */\n  getLogForRun(params) {\n    return this.request(`/api/logs/${params.runId}?transportId=${params.transportId}`);\n  }\n  /**\n   * List of all log transports\n   * @returns Promise containing list of log transports\n   */\n  getLogTransports() {\n    return this.request(\"/api/logs/transports\");\n  }\n  /**\n   * List of all traces (paged)\n   * @param params - Parameters for filtering traces\n   * @returns Promise containing telemetry data\n   */\n  getTelemetry(params) {\n    const { name, scope, page, perPage, attribute, fromDate, toDate } = params || {};\n    const _attribute = attribute ? Object.entries(attribute).map(([key, value]) => `${key}:${value}`) : [];\n    const searchParams = new URLSearchParams();\n    if (name) {\n      searchParams.set(\"name\", name);\n    }\n    if (scope) {\n      searchParams.set(\"scope\", scope);\n    }\n    if (page) {\n      searchParams.set(\"page\", String(page));\n    }\n    if (perPage) {\n      searchParams.set(\"perPage\", String(perPage));\n    }\n    if (_attribute) {\n      if (Array.isArray(_attribute)) {\n        for (const attr of _attribute) {\n          searchParams.append(\"attribute\", attr);\n        }\n      } else {\n        searchParams.set(\"attribute\", _attribute);\n      }\n    }\n    if (fromDate) {\n      searchParams.set(\"fromDate\", fromDate.toISOString());\n    }\n    if (toDate) {\n      searchParams.set(\"toDate\", toDate.toISOString());\n    }\n    if (searchParams.size) {\n      return this.request(`/api/telemetry?${searchParams}`);\n    } else {\n      return this.request(`/api/telemetry`);\n    }\n  }\n  /**\n   * Retrieves all available networks\n   * @returns Promise containing map of network IDs to network details\n   */\n  getNetworks() {\n    return this.request(\"/api/networks\");\n  }\n  /**\n   * Gets a network instance by ID\n   * @param networkId - ID of the network to retrieve\n   * @returns Network instance\n   */\n  getNetwork(networkId) {\n    return new Network(this.options, networkId);\n  }\n  /**\n   * Retrieves a list of available MCP servers.\n   * @param params - Optional parameters for pagination (limit, offset).\n   * @returns Promise containing the list of MCP servers and pagination info.\n   */\n  getMcpServers(params) {\n    const searchParams = new URLSearchParams();\n    if (params?.limit !== void 0) {\n      searchParams.set(\"limit\", String(params.limit));\n    }\n    if (params?.offset !== void 0) {\n      searchParams.set(\"offset\", String(params.offset));\n    }\n    const queryString = searchParams.toString();\n    return this.request(`/api/mcp/v0/servers${queryString ? `?${queryString}` : \"\"}`);\n  }\n  /**\n   * Retrieves detailed information for a specific MCP server.\n   * @param serverId - The ID of the MCP server to retrieve.\n   * @param params - Optional parameters, e.g., specific version.\n   * @returns Promise containing the detailed MCP server information.\n   */\n  getMcpServerDetails(serverId, params) {\n    const searchParams = new URLSearchParams();\n    if (params?.version) {\n      searchParams.set(\"version\", params.version);\n    }\n    const queryString = searchParams.toString();\n    return this.request(`/api/mcp/v0/servers/${serverId}${queryString ? `?${queryString}` : \"\"}`);\n  }\n  /**\n   * Retrieves a list of tools for a specific MCP server.\n   * @param serverId - The ID of the MCP server.\n   * @returns Promise containing the list of tools.\n   */\n  getMcpServerTools(serverId) {\n    return this.request(`/api/mcp/${serverId}/tools`);\n  }\n  /**\n   * Gets an MCPTool resource instance for a specific tool on an MCP server.\n   * This instance can then be used to fetch details or execute the tool.\n   * @param serverId - The ID of the MCP server.\n   * @param toolId - The ID of the tool.\n   * @returns MCPTool instance.\n   */\n  getMcpServerTool(serverId, toolId) {\n    return new MCPTool(this.options, serverId, toolId);\n  }\n  /**\n   * Gets an A2A client for interacting with an agent via the A2A protocol\n   * @param agentId - ID of the agent to interact with\n   * @returns A2A client instance\n   */\n  getA2A(agentId) {\n    return new A2A(this.options, agentId);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hc3RyYS9jbGllbnQtanMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5RDtBQUN2QjtBQUNtQjtBQUNyQjtBQUN5QjtBQUNLOztBQUU5RDtBQUNBLGdDQUFnQyx3REFBYTtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFVO0FBQ3pCO0FBQ0E7QUFDQSxjQUFjLG9EQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFTO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixvREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0Isb0RBQVM7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0IiLCJzb3VyY2VzIjpbIi9ob21lL210YWhhc3lsbXovRGVza3RvcC91cHN0YXNoL21hc3RyYS93aXRoQXBpL25vZGVfbW9kdWxlcy9AbWFzdHJhL2NsaWVudC1qcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0QWdlbnQsIEV2ZW50VHlwZSB9IGZyb20gJ0BhZy11aS9jbGllbnQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgcHJvY2Vzc0RhdGFTdHJlYW0gfSBmcm9tICdAYWktc2RrL3VpLXV0aWxzJztcbmltcG9ydCB7IFpvZFNjaGVtYSB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgb3JpZ2luYWxab2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcbmltcG9ydCB7IFJ1bnRpbWVDb250ZXh0IH0gZnJvbSAnQG1hc3RyYS9jb3JlL3J1bnRpbWUtY29udGV4dCc7XG5cbi8vIHNyYy9hZGFwdGVycy9hZ3VpLnRzXG52YXIgQUdVSUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0QWdlbnQge1xuICBhZ2VudDtcbiAgcmVzb3VyY2VJZDtcbiAgY29uc3RydWN0b3IoeyBhZ2VudCwgYWdlbnRJZCwgcmVzb3VyY2VJZCwgLi4ucmVzdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgYWdlbnRJZCxcbiAgICAgIC4uLnJlc3RcbiAgICB9KTtcbiAgICB0aGlzLmFnZW50ID0gYWdlbnQ7XG4gICAgdGhpcy5yZXNvdXJjZUlkID0gcmVzb3VyY2VJZDtcbiAgfVxuICBydW4oaW5wdXQpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgIGNvbnN0IGNvbnZlcnRlZE1lc3NhZ2VzID0gY29udmVydE1lc3NhZ2VzVG9NYXN0cmFNZXNzYWdlcyhpbnB1dC5tZXNzYWdlcyk7XG4gICAgICBzdWJzY3JpYmVyLm5leHQoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuUlVOX1NUQVJURUQsXG4gICAgICAgIHRocmVhZElkOiBpbnB1dC50aHJlYWRJZCxcbiAgICAgICAgcnVuSWQ6IGlucHV0LnJ1bklkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWdlbnQuc3RyZWFtKHtcbiAgICAgICAgdGhyZWFkSWQ6IGlucHV0LnRocmVhZElkLFxuICAgICAgICByZXNvdXJjZUlkOiB0aGlzLnJlc291cmNlSWQgPz8gXCJcIixcbiAgICAgICAgcnVuSWQ6IGlucHV0LnJ1bklkLFxuICAgICAgICBtZXNzYWdlczogY29udmVydGVkTWVzc2FnZXMsXG4gICAgICAgIGNsaWVudFRvb2xzOiBpbnB1dC50b29scy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgdG9vbCkgPT4ge1xuICAgICAgICAgICAgYWNjW3Rvb2wubmFtZV0gPSB7XG4gICAgICAgICAgICAgIGlkOiB0b29sLm5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBpbnB1dFNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHt9XG4gICAgICAgIClcbiAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50TWVzc2FnZUlkID0gdm9pZCAwO1xuICAgICAgICBsZXQgaXNJblRleHRNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5wcm9jZXNzRGF0YVN0cmVhbSh7XG4gICAgICAgICAgb25UZXh0UGFydDogKHRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWVzc2FnZUlkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2VJZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlMiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuVEVYVF9NRVNTQUdFX1NUQVJULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogY3VycmVudE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChtZXNzYWdlMik7XG4gICAgICAgICAgICAgIGlzSW5UZXh0TWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuVEVYVF9NRVNTQUdFX0NPTlRFTlQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogY3VycmVudE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgZGVsdGE6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQobWVzc2FnZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkZpbmlzaE1lc3NhZ2VQYXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE1lc3NhZ2VJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlRFWFRfTUVTU0FHRV9FTkQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiBjdXJyZW50TWVzc2FnZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgaXNJblRleHRNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUlVOX0ZJTklTSEVELFxuICAgICAgICAgICAgICB0aHJlYWRJZDogaW5wdXQudGhyZWFkSWQsXG4gICAgICAgICAgICAgIHJ1bklkOiBpbnB1dC5ydW5JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblRvb2xDYWxsUGFydChzdHJlYW1QYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRNZXNzYWdlSWQgPSBjdXJyZW50TWVzc2FnZUlkIHx8IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICAgICAgaWYgKGlzSW5UZXh0TWVzc2FnZSkge1xuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5URVhUX01FU1NBR0VfRU5ELFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogcGFyZW50TWVzc2FnZUlkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgaXNJblRleHRNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoe1xuICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuVE9PTF9DQUxMX1NUQVJULFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBzdHJlYW1QYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xDYWxsTmFtZTogc3RyZWFtUGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgcGFyZW50TWVzc2FnZUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5UT09MX0NBTExfQVJHUyxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogc3RyZWFtUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICBkZWx0YTogSlNPTi5zdHJpbmdpZnkoc3RyZWFtUGFydC5hcmdzKSxcbiAgICAgICAgICAgICAgcGFyZW50TWVzc2FnZUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh7XG4gICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5UT09MX0NBTExfRU5ELFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBzdHJlYW1QYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHBhcmVudE1lc3NhZ2VJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmZmVyKTtcbiAgICAgIGJ1ZmZlcls2XSA9IGJ1ZmZlcls2XSAmIDE1IHwgNjQ7XG4gICAgICBidWZmZXJbOF0gPSBidWZmZXJbOF0gJiA2MyB8IDEyODtcbiAgICAgIGxldCBoZXggPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGhleCArPSBidWZmZXJbaV0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIGhleCArPSBcIi1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICBjb25zdCB2ID0gYyA9PT0gXCJ4XCIgPyByIDogciAmIDMgfCA4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0TWVzc2FnZXNUb01hc3RyYU1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IG1lc3NhZ2UuY29udGVudCA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0gOiBbXTtcbiAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgbWVzc2FnZS50b29sQ2FsbHMgPz8gW10pIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICBhcmdzOiBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IHBhcnRzXG4gICAgICB9KTtcbiAgICAgIGlmIChtZXNzYWdlLnRvb2xDYWxscz8ubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLnRvb2xDYWxscy5tYXAoKHRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHJlc3VsdDogSlNPTi5wYXJzZSh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5yb2xlID09PSBcInVzZXJcIikge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50IHx8IFwiXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5yb2xlID09PSBcInRvb2xcIikge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG1lc3NhZ2UudG9vbENhbGxJZCxcbiAgICAgICAgICAgIHRvb2xOYW1lOiBcInVua25vd25cIixcbiAgICAgICAgICAgIHJlc3VsdDogbWVzc2FnZS5jb250ZW50XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpIHtcbiAgaWYgKCEoem9kU2NoZW1hIGluc3RhbmNlb2YgWm9kU2NoZW1hKSkge1xuICAgIHJldHVybiB6b2RTY2hlbWE7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbmFsWm9kVG9Kc29uU2NoZW1hKHpvZFNjaGVtYSwgeyAkcmVmU3RyYXRlZ3k6IFwibm9uZVwiIH0pO1xufVxuXG4vLyBzcmMvcmVzb3VyY2VzL2Jhc2UudHNcbnZhciBCYXNlUmVzb3VyY2UgPSBjbGFzcyB7XG4gIG9wdGlvbnM7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhbiBIVFRQIHJlcXVlc3QgdG8gdGhlIEFQSSB3aXRoIHJldHJpZXMgYW5kIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICogQHBhcmFtIHBhdGggLSBUaGUgQVBJIGVuZHBvaW50IHBhdGhcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCByZXF1ZXN0IGNvbmZpZ3VyYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSByZXNwb25zZSBkYXRhXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHsgYmFzZVVybCwgcmV0cmllcyA9IDMsIGJhY2tvZmZNcyA9IDEwMCwgbWF4QmFja29mZk1zID0gMWUzLCBoZWFkZXJzID0ge30gfSA9IHRoaXMub3B0aW9ucztcbiAgICBsZXQgZGVsYXkgPSBiYWNrb2ZmTXM7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPD0gcmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2Jhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpfSR7cGF0aH1gLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICAgICAgICAvLyBUT0RPOiBCcmluZyB0aGlzIGJhY2sgb25jZSB3ZSBmaWd1cmUgb3V0IHdoYXQgd2UvdXNlcnMgbmVlZCB0byBkbyB0byBtYWtlIHRoaXMgd29yayB3aXRoIGNyb3NzLW9yaWdpbiByZXF1ZXN0c1xuICAgICAgICAgICAgLy8gJ3gtbWFzdHJhLWNsaWVudC10eXBlJzogJ2pzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gb3B0aW9ucy5ib2R5IDogb3B0aW9ucy5ib2R5ID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShlcnJvckJvZHkpO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9ySnNvbil9YDtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGlmIChlcnJvckJvZHkpIHtcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAgLSAke2Vycm9yQm9keX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdHJlYW0pIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IHJldHJpZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICBkZWxheSA9IE1hdGgubWluKGRlbGF5ICogMiwgbWF4QmFja29mZk1zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcihcIlJlcXVlc3QgZmFpbGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VDbGllbnRSdW50aW1lQ29udGV4dChydW50aW1lQ29udGV4dCkge1xuICBpZiAocnVudGltZUNvbnRleHQpIHtcbiAgICBpZiAocnVudGltZUNvbnRleHQgaW5zdGFuY2VvZiBSdW50aW1lQ29udGV4dCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhydW50aW1lQ29udGV4dC5lbnRyaWVzKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL3Jlc291cmNlcy9hZ2VudC50c1xudmFyIEFnZW50Vm9pY2UgPSBjbGFzcyBleHRlbmRzIEJhc2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFnZW50SWQpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLmFnZW50SWQgPSBhZ2VudElkO1xuICAgIHRoaXMuYWdlbnRJZCA9IGFnZW50SWQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgdGV4dCB0byBzcGVlY2ggdXNpbmcgdGhlIGFnZW50J3Mgdm9pY2UgcHJvdmlkZXJcbiAgICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGNvbnZlcnQgdG8gc3BlZWNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgcHJvdmlkZXItc3BlY2lmaWMgb3B0aW9ucyBmb3Igc3BlZWNoIGdlbmVyYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBhdWRpbyBkYXRhXG4gICAqL1xuICBhc3luYyBzcGVhayh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9hZ2VudHMvJHt0aGlzLmFnZW50SWR9L3ZvaWNlL3NwZWFrYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiB7IGlucHV0OiB0ZXh0LCBvcHRpb25zIH0sXG4gICAgICBzdHJlYW06IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBzcGVlY2ggdG8gdGV4dCB1c2luZyB0aGUgYWdlbnQncyB2b2ljZSBwcm92aWRlclxuICAgKiBAcGFyYW0gYXVkaW8gLSBBdWRpbyBkYXRhIHRvIHRyYW5zY3JpYmVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBvcHRpb25zXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdHJhbnNjcmliZWQgdGV4dFxuICAgKi9cbiAgbGlzdGVuKGF1ZGlvLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJhdWRpb1wiLCBhdWRpbyk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm9wdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FnZW50cy8ke3RoaXMuYWdlbnRJZH0vdm9pY2UvbGlzdGVuYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhdmFpbGFibGUgc3BlYWtlcnMgZm9yIHRoZSBhZ2VudCdzIHZvaWNlIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBsaXN0IG9mIGF2YWlsYWJsZSBzcGVha2Vyc1xuICAgKi9cbiAgZ2V0U3BlYWtlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9hZ2VudHMvJHt0aGlzLmFnZW50SWR9L3ZvaWNlL3NwZWFrZXJzYCk7XG4gIH1cbn07XG52YXIgQWdlbnQgPSBjbGFzcyBleHRlbmRzIEJhc2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFnZW50SWQpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLmFnZW50SWQgPSBhZ2VudElkO1xuICAgIHRoaXMudm9pY2UgPSBuZXcgQWdlbnRWb2ljZShvcHRpb25zLCB0aGlzLmFnZW50SWQpO1xuICB9XG4gIHZvaWNlO1xuICAvKipcbiAgICogUmV0cmlldmVzIGRldGFpbHMgYWJvdXQgdGhlIGFnZW50XG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhZ2VudCBkZXRhaWxzIGluY2x1ZGluZyBtb2RlbCBhbmQgaW5zdHJ1Y3Rpb25zXG4gICAqL1xuICBkZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWdlbnRzLyR7dGhpcy5hZ2VudElkfWApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXNwb25zZSBmcm9tIHRoZSBhZ2VudFxuICAgKiBAcGFyYW0gcGFyYW1zIC0gR2VuZXJhdGlvbiBwYXJhbWV0ZXJzIGluY2x1ZGluZyBwcm9tcHRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcmVzcG9uc2VcbiAgICovXG4gIGdlbmVyYXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHByb2Nlc3NlZFBhcmFtcyA9IHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG91dHB1dDogcGFyYW1zLm91dHB1dCA/IHpvZFRvSnNvblNjaGVtYShwYXJhbXMub3V0cHV0KSA6IHZvaWQgMCxcbiAgICAgIGV4cGVyaW1lbnRhbF9vdXRwdXQ6IHBhcmFtcy5leHBlcmltZW50YWxfb3V0cHV0ID8gem9kVG9Kc29uU2NoZW1hKHBhcmFtcy5leHBlcmltZW50YWxfb3V0cHV0KSA6IHZvaWQgMCxcbiAgICAgIHJ1bnRpbWVDb250ZXh0OiBwYXJzZUNsaWVudFJ1bnRpbWVDb250ZXh0KHBhcmFtcy5ydW50aW1lQ29udGV4dClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWdlbnRzLyR7dGhpcy5hZ2VudElkfS9nZW5lcmF0ZWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBwcm9jZXNzZWRQYXJhbXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RyZWFtcyBhIHJlc3BvbnNlIGZyb20gdGhlIGFnZW50XG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTdHJlYW0gcGFyYW1ldGVycyBpbmNsdWRpbmcgcHJvbXB0XG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgZW5oYW5jZWQgUmVzcG9uc2Ugb2JqZWN0IHdpdGggcHJvY2Vzc0RhdGFTdHJlYW0gbWV0aG9kXG4gICAqL1xuICBhc3luYyBzdHJlYW0ocGFyYW1zKSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkUGFyYW1zID0ge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgb3V0cHV0OiBwYXJhbXMub3V0cHV0ID8gem9kVG9Kc29uU2NoZW1hKHBhcmFtcy5vdXRwdXQpIDogdm9pZCAwLFxuICAgICAgZXhwZXJpbWVudGFsX291dHB1dDogcGFyYW1zLmV4cGVyaW1lbnRhbF9vdXRwdXQgPyB6b2RUb0pzb25TY2hlbWEocGFyYW1zLmV4cGVyaW1lbnRhbF9vdXRwdXQpIDogdm9pZCAwLFxuICAgICAgcnVudGltZUNvbnRleHQ6IHBhcnNlQ2xpZW50UnVudGltZUNvbnRleHQocGFyYW1zLnJ1bnRpbWVDb250ZXh0KVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hcGkvYWdlbnRzLyR7dGhpcy5hZ2VudElkfS9zdHJlYW1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcHJvY2Vzc2VkUGFyYW1zLFxuICAgICAgc3RyZWFtOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXNwb25zZSBib2R5XCIpO1xuICAgIH1cbiAgICByZXNwb25zZS5wcm9jZXNzRGF0YVN0cmVhbSA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGF3YWl0IHByb2Nlc3NEYXRhU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBkZXRhaWxzIGFib3V0IGEgc3BlY2lmaWMgdG9vbCBhdmFpbGFibGUgdG8gdGhlIGFnZW50XG4gICAqIEBwYXJhbSB0b29sSWQgLSBJRCBvZiB0aGUgdG9vbCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdG9vbCBkZXRhaWxzXG4gICAqL1xuICBnZXRUb29sKHRvb2xJZCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvYWdlbnRzLyR7dGhpcy5hZ2VudElkfS90b29scy8ke3Rvb2xJZH1gKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYSB0b29sIGZvciB0aGUgYWdlbnRcbiAgICogQHBhcmFtIHRvb2xJZCAtIElEIG9mIHRoZSB0b29sIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgcmVxdWlyZWQgZm9yIHRvb2wgZXhlY3V0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdG9vbCBleGVjdXRpb24gcmVzdWx0c1xuICAgKi9cbiAgZXhlY3V0ZVRvb2wodG9vbElkLCBwYXJhbXMpIHtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgZGF0YTogcGFyYW1zLmRhdGEsXG4gICAgICBydW50aW1lQ29udGV4dDogcGFyYW1zLnJ1bnRpbWVDb250ZXh0ID8gT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcy5ydW50aW1lQ29udGV4dC5lbnRyaWVzKCkpIDogdm9pZCAwXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FnZW50cy8ke3RoaXMuYWdlbnRJZH0vdG9vbHMvJHt0b29sSWR9L2V4ZWN1dGVgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgZXZhbHVhdGlvbiByZXN1bHRzIGZvciB0aGUgYWdlbnRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFnZW50IGV2YWx1YXRpb25zXG4gICAqL1xuICBldmFscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FnZW50cy8ke3RoaXMuYWdlbnRJZH0vZXZhbHMvY2lgKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGxpdmUgZXZhbHVhdGlvbiByZXN1bHRzIGZvciB0aGUgYWdlbnRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGxpdmUgYWdlbnQgZXZhbHVhdGlvbnNcbiAgICovXG4gIGxpdmVFdmFscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL2FnZW50cy8ke3RoaXMuYWdlbnRJZH0vZXZhbHMvbGl2ZWApO1xuICB9XG59O1xudmFyIE5ldHdvcmsgPSBjbGFzcyBleHRlbmRzIEJhc2VSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIG5ldHdvcmtJZCkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMubmV0d29ya0lkID0gbmV0d29ya0lkO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCB0aGUgbmV0d29ya1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgbmV0d29yayBkZXRhaWxzXG4gICAqL1xuICBkZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvbmV0d29ya3MvJHt0aGlzLm5ldHdvcmtJZH1gKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVzcG9uc2UgZnJvbSB0aGUgYWdlbnRcbiAgICogQHBhcmFtIHBhcmFtcyAtIEdlbmVyYXRpb24gcGFyYW1ldGVycyBpbmNsdWRpbmcgcHJvbXB0XG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHJlc3BvbnNlXG4gICAqL1xuICBnZW5lcmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCBwcm9jZXNzZWRQYXJhbXMgPSB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvdXRwdXQ6IHpvZFRvSnNvblNjaGVtYShwYXJhbXMub3V0cHV0KSxcbiAgICAgIGV4cGVyaW1lbnRhbF9vdXRwdXQ6IHpvZFRvSnNvblNjaGVtYShwYXJhbXMuZXhwZXJpbWVudGFsX291dHB1dClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvbmV0d29ya3MvJHt0aGlzLm5ldHdvcmtJZH0vZ2VuZXJhdGVgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcHJvY2Vzc2VkUGFyYW1zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSByZXNwb25zZSBmcm9tIHRoZSBhZ2VudFxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3RyZWFtIHBhcmFtZXRlcnMgaW5jbHVkaW5nIHByb21wdFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGVuaGFuY2VkIFJlc3BvbnNlIG9iamVjdCB3aXRoIHByb2Nlc3NEYXRhU3RyZWFtIG1ldGhvZFxuICAgKi9cbiAgYXN5bmMgc3RyZWFtKHBhcmFtcykge1xuICAgIGNvbnN0IHByb2Nlc3NlZFBhcmFtcyA9IHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG91dHB1dDogem9kVG9Kc29uU2NoZW1hKHBhcmFtcy5vdXRwdXQpLFxuICAgICAgZXhwZXJpbWVudGFsX291dHB1dDogem9kVG9Kc29uU2NoZW1hKHBhcmFtcy5leHBlcmltZW50YWxfb3V0cHV0KVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hcGkvbmV0d29ya3MvJHt0aGlzLm5ldHdvcmtJZH0vc3RyZWFtYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHByb2Nlc3NlZFBhcmFtcyxcbiAgICAgIHN0cmVhbTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgYm9keVwiKTtcbiAgICB9XG4gICAgcmVzcG9uc2UucHJvY2Vzc0RhdGFTdHJlYW0gPSBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBhd2FpdCBwcm9jZXNzRGF0YVN0cmVhbSh7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNvdXJjZXMvbWVtb3J5LXRocmVhZC50c1xudmFyIE1lbW9yeVRocmVhZCA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgdGhyZWFkSWQsIGFnZW50SWQpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnRocmVhZElkID0gdGhyZWFkSWQ7XG4gICAgdGhpcy5hZ2VudElkID0gYWdlbnRJZDtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBtZW1vcnkgdGhyZWFkIGRldGFpbHNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRocmVhZCBkZXRhaWxzIGluY2x1ZGluZyB0aXRsZSBhbmQgbWV0YWRhdGFcbiAgICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL21lbW9yeS90aHJlYWRzLyR7dGhpcy50aHJlYWRJZH0/YWdlbnRJZD0ke3RoaXMuYWdlbnRJZH1gKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWVtb3J5IHRocmVhZCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBVcGRhdGUgcGFyYW1ldGVycyBpbmNsdWRpbmcgdGl0bGUgYW5kIG1ldGFkYXRhXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB1cGRhdGVkIHRocmVhZCBkZXRhaWxzXG4gICAqL1xuICB1cGRhdGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tZW1vcnkvdGhyZWFkcy8ke3RoaXMudGhyZWFkSWR9P2FnZW50SWQ9JHt0aGlzLmFnZW50SWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICBib2R5OiBwYXJhbXNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgbWVtb3J5IHRocmVhZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgZGVsZXRpb24gcmVzdWx0XG4gICAqL1xuICBkZWxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tZW1vcnkvdGhyZWFkcy8ke3RoaXMudGhyZWFkSWR9P2FnZW50SWQ9JHt0aGlzLmFnZW50SWR9YCwge1xuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtZXNzYWdlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHRocmVhZFxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBpbmNsdWRpbmcgbGltaXQgZm9yIG51bWJlciBvZiBtZXNzYWdlcyB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhyZWFkIG1lc3NhZ2VzIGFuZCBVSSBtZXNzYWdlc1xuICAgKi9cbiAgZ2V0TWVzc2FnZXMocGFyYW1zKSB7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIGFnZW50SWQ6IHRoaXMuYWdlbnRJZCxcbiAgICAgIC4uLnBhcmFtcz8ubGltaXQgPyB7IGxpbWl0OiBwYXJhbXMubGltaXQudG9TdHJpbmcoKSB9IDoge31cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL21lbW9yeS90aHJlYWRzLyR7dGhpcy50aHJlYWRJZH0vbWVzc2FnZXM/JHtxdWVyeS50b1N0cmluZygpfWApO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzb3VyY2VzL3ZlY3Rvci50c1xudmFyIFZlY3RvciA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgdmVjdG9yTmFtZSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMudmVjdG9yTmFtZSA9IHZlY3Rvck5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBnZXQgZGV0YWlscyBmb3JcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHZlY3RvciBpbmRleCBkZXRhaWxzXG4gICAqL1xuICBkZXRhaWxzKGluZGV4TmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdmVjdG9yLyR7dGhpcy52ZWN0b3JOYW1lfS9pbmRleGVzLyR7aW5kZXhOYW1lfWApO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgdmVjdG9yIGluZGV4XG4gICAqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBkZWxldGVcbiAgICogQHJldHVybnMgUHJvbWlzZSBpbmRpY2F0aW5nIGRlbGV0aW9uIHN1Y2Nlc3NcbiAgICovXG4gIGRlbGV0ZShpbmRleE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3ZlY3Rvci8ke3RoaXMudmVjdG9yTmFtZX0vaW5kZXhlcy8ke2luZGV4TmFtZX1gLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGluZGV4ZXNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIGluZGV4IG5hbWVzXG4gICAqL1xuICBnZXRJbmRleGVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdmVjdG9yLyR7dGhpcy52ZWN0b3JOYW1lfS9pbmRleGVzYCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4XG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBpbmRleCBjcmVhdGlvbiBpbmNsdWRpbmcgZGltZW5zaW9uIGFuZCBtZXRyaWNcbiAgICogQHJldHVybnMgUHJvbWlzZSBpbmRpY2F0aW5nIGNyZWF0aW9uIHN1Y2Nlc3NcbiAgICovXG4gIGNyZWF0ZUluZGV4KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdmVjdG9yLyR7dGhpcy52ZWN0b3JOYW1lfS9jcmVhdGUtaW5kZXhgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcGFyYW1zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwc2VydHMgdmVjdG9ycyBpbnRvIGFuIGluZGV4XG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdmVjdG9ycywgbWV0YWRhdGEsIGFuZCBvcHRpb25hbCBJRHNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIHZlY3RvciBJRHNcbiAgICovXG4gIHVwc2VydChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3ZlY3Rvci8ke3RoaXMudmVjdG9yTmFtZX0vdXBzZXJ0YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHBhcmFtc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBRdWVyaWVzIHZlY3RvcnMgaW4gYW4gaW5kZXhcbiAgICogQHBhcmFtIHBhcmFtcyAtIFF1ZXJ5IHBhcmFtZXRlcnMgaW5jbHVkaW5nIHF1ZXJ5IHZlY3RvciBhbmQgc2VhcmNoIG9wdGlvbnNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHF1ZXJ5IHJlc3VsdHNcbiAgICovXG4gIHF1ZXJ5KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdmVjdG9yLyR7dGhpcy52ZWN0b3JOYW1lfS9xdWVyeWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBwYXJhbXNcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc291cmNlcy9sZWdhY3ktd29ya2Zsb3cudHNcbnZhciBSRUNPUkRfU0VQQVJBVE9SID0gXCJcdTAwMWVcIjtcbnZhciBMZWdhY3lXb3JrZmxvdyA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgd29ya2Zsb3dJZCkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMud29ya2Zsb3dJZCA9IHdvcmtmbG93SWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IHRoZSBsZWdhY3kgd29ya2Zsb3dcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGxlZ2FjeSB3b3JrZmxvdyBkZXRhaWxzIGluY2x1ZGluZyBzdGVwcyBhbmQgZ3JhcGhzXG4gICAqL1xuICBkZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzL2xlZ2FjeS8ke3RoaXMud29ya2Zsb3dJZH1gKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCBydW5zIGZvciBhIGxlZ2FjeSB3b3JrZmxvd1xuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgZmlsdGVyaW5nIHJ1bnNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGxlZ2FjeSB3b3JrZmxvdyBydW5zIGFycmF5XG4gICAqL1xuICBydW5zKHBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAocGFyYW1zPy5mcm9tRGF0ZSkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcImZyb21EYXRlXCIsIHBhcmFtcy5mcm9tRGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcz8udG9EYXRlKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwidG9EYXRlXCIsIHBhcmFtcy50b0RhdGUudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXM/LmxpbWl0KSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKHBhcmFtcy5saW1pdCkpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zPy5vZmZzZXQpIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKHBhcmFtcy5vZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcz8ucmVzb3VyY2VJZCkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcInJlc291cmNlSWRcIiwgcGFyYW1zLnJlc291cmNlSWQpO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoUGFyYW1zLnNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzL2xlZ2FjeS8ke3RoaXMud29ya2Zsb3dJZH0vcnVucz8ke3NlYXJjaFBhcmFtc31gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS93b3JrZmxvd3MvbGVnYWN5LyR7dGhpcy53b3JrZmxvd0lkfS9ydW5zYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGxlZ2FjeSB3b3JrZmxvdyBydW5cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcnVuIElEXG4gICAqL1xuICBjcmVhdGVSdW4ocGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmICghIXBhcmFtcz8ucnVuSWQpIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJydW5JZFwiLCBwYXJhbXMucnVuSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy9sZWdhY3kvJHt0aGlzLndvcmtmbG93SWR9L2NyZWF0ZS1ydW4/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIGxlZ2FjeSB3b3JrZmxvdyBydW4gc3luY2hyb25vdXNseSB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSB3b3JrZmxvdyB0byBjb21wbGV0ZVxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJ1bklkIGFuZCB0cmlnZ2VyRGF0YVxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlXG4gICAqL1xuICBzdGFydChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy9sZWdhY3kvJHt0aGlzLndvcmtmbG93SWR9L3N0YXJ0P3J1bklkPSR7cGFyYW1zLnJ1bklkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBwYXJhbXM/LnRyaWdnZXJEYXRhXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgYSBzdXNwZW5kZWQgbGVnYWN5IHdvcmtmbG93IHN0ZXAgc3luY2hyb25vdXNseSB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSB3b3JrZmxvdyB0byBjb21wbGV0ZVxuICAgKiBAcGFyYW0gc3RlcElkIC0gSUQgb2YgdGhlIHN0ZXAgdG8gcmVzdW1lXG4gICAqIEBwYXJhbSBydW5JZCAtIElEIG9mIHRoZSBsZWdhY3kgd29ya2Zsb3cgcnVuXG4gICAqIEBwYXJhbSBjb250ZXh0IC0gQ29udGV4dCB0byByZXN1bWUgdGhlIGxlZ2FjeSB3b3JrZmxvdyB3aXRoXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgbGVnYWN5IHdvcmtmbG93IHJlc3VtZSByZXN1bHRzXG4gICAqL1xuICByZXN1bWUoe1xuICAgIHN0ZXBJZCxcbiAgICBydW5JZCxcbiAgICBjb250ZXh0XG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy9sZWdhY3kvJHt0aGlzLndvcmtmbG93SWR9L3Jlc3VtZT9ydW5JZD0ke3J1bklkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHN0ZXBJZCxcbiAgICAgICAgY29udGV4dFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgYSB3b3JrZmxvdyBydW4gYXN5bmNocm9ub3VzbHkgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgd29ya2Zsb3cgaXMgY29tcGxldGVcbiAgICogQHBhcmFtIHBhcmFtcyAtIE9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25hbCBydW5JZCBhbmQgdHJpZ2dlckRhdGFcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSB3b3JrZmxvdyBleGVjdXRpb24gcmVzdWx0c1xuICAgKi9cbiAgc3RhcnRBc3luYyhwYXJhbXMpIHtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKCEhcGFyYW1zPy5ydW5JZCkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcInJ1bklkXCIsIHBhcmFtcy5ydW5JZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzL2xlZ2FjeS8ke3RoaXMud29ya2Zsb3dJZH0vc3RhcnQtYXN5bmM/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcGFyYW1zPy50cmlnZ2VyRGF0YVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWVzIGEgc3VzcGVuZGVkIGxlZ2FjeSB3b3JrZmxvdyBzdGVwIGFzeW5jaHJvbm91c2x5IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHdvcmtmbG93IGlzIGNvbXBsZXRlXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBPYmplY3QgY29udGFpbmluZyB0aGUgcnVuSWQsIHN0ZXBJZCwgYW5kIGNvbnRleHRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSB3b3JrZmxvdyByZXN1bWUgcmVzdWx0c1xuICAgKi9cbiAgcmVzdW1lQXN5bmMocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS93b3JrZmxvd3MvbGVnYWN5LyR7dGhpcy53b3JrZmxvd0lkfS9yZXN1bWUtYXN5bmM/cnVuSWQ9JHtwYXJhbXMucnVuSWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgc3RlcElkOiBwYXJhbXMuc3RlcElkLFxuICAgICAgICBjb250ZXh0OiBwYXJhbXMuY29udGV4dFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jIGdlbmVyYXRvciB0aGF0IHByb2Nlc3NlcyBhIHJlYWRhYmxlIHN0cmVhbSBhbmQgeWllbGRzIHJlY29yZHNcbiAgICogc2VwYXJhdGVkIGJ5IHRoZSBSZWNvcmQgU2VwYXJhdG9yIGNoYXJhY3RlciAoXFx4MUUpXG4gICAqXG4gICAqIEBwYXJhbSBzdHJlYW0gLSBUaGUgcmVhZGFibGUgc3RyZWFtIHRvIHByb2Nlc3NcbiAgICogQHJldHVybnMgQW4gYXN5bmMgZ2VuZXJhdG9yIHRoYXQgeWllbGRzIHBhcnNlZCByZWNvcmRzXG4gICAqL1xuICBhc3luYyAqc3RyZWFtUHJvY2Vzc29yKHN0cmVhbSkge1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgZG9uZVJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKCFkb25lUmVhZGluZykge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBkb25lUmVhZGluZyA9IGRvbmU7XG4gICAgICAgIGlmIChkb25lICYmICF2YWx1ZSkgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjb2RlZCA9IHZhbHVlID8gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gKGJ1ZmZlciArIGRlY29kZWQpLnNwbGl0KFJFQ09SRF9TRVBBUkFUT1IpO1xuICAgICAgICAgIGJ1ZmZlciA9IGNodW5rcy5wb3AoKSB8fCBcIlwiO1xuICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRDaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgeWllbGQgcGFyc2VkQ2h1bms7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2UoYnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogV2F0Y2hlcyBsZWdhY3kgd29ya2Zsb3cgdHJhbnNpdGlvbnMgaW4gcmVhbC10aW1lXG4gICAqIEBwYXJhbSBydW5JZCAtIE9wdGlvbmFsIHJ1biBJRCB0byBmaWx0ZXIgdGhlIHdhdGNoIHN0cmVhbVxuICAgKiBAcmV0dXJucyBBc3luY0dlbmVyYXRvciB0aGF0IHlpZWxkcyBwYXJzZWQgcmVjb3JkcyBmcm9tIHRoZSBsZWdhY3kgd29ya2Zsb3cgd2F0Y2ggc3RyZWFtXG4gICAqL1xuICBhc3luYyB3YXRjaCh7IHJ1bklkIH0sIG9uUmVjb3JkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzL2xlZ2FjeS8ke3RoaXMud29ya2Zsb3dJZH0vd2F0Y2g/cnVuSWQ9JHtydW5JZH1gLCB7XG4gICAgICBzdHJlYW06IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3YXRjaCBsZWdhY3kgd29ya2Zsb3c6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gICAgfVxuICAgIGZvciBhd2FpdCAoY29uc3QgcmVjb3JkIG9mIHRoaXMuc3RyZWFtUHJvY2Vzc29yKHJlc3BvbnNlLmJvZHkpKSB7XG4gICAgICBvblJlY29yZChyZWNvcmQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3Jlc291cmNlcy90b29sLnRzXG52YXIgVG9vbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgdG9vbElkKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy50b29sSWQgPSB0b29sSWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBkZXRhaWxzIGFib3V0IHRoZSB0b29sXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0b29sIGRldGFpbHMgaW5jbHVkaW5nIGRlc2NyaXB0aW9uIGFuZCBzY2hlbWFzXG4gICAqL1xuICBkZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvdG9vbHMvJHt0aGlzLnRvb2xJZH1gKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHRvb2wgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyByZXF1aXJlZCBmb3IgdG9vbCBleGVjdXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSB0b29sIGV4ZWN1dGlvbiByZXN1bHRzXG4gICAqL1xuICBleGVjdXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAocGFyYW1zLnJ1bklkKSB7XG4gICAgICB1cmwuc2V0KFwicnVuSWRcIiwgcGFyYW1zLnJ1bklkKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIGRhdGE6IHBhcmFtcy5kYXRhLFxuICAgICAgcnVudGltZUNvbnRleHQ6IHBhcnNlQ2xpZW50UnVudGltZUNvbnRleHQocGFyYW1zLnJ1bnRpbWVDb250ZXh0KVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS90b29scy8ke3RoaXMudG9vbElkfS9leGVjdXRlPyR7dXJsLnRvU3RyaW5nKCl9YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc291cmNlcy93b3JrZmxvdy50c1xudmFyIFJFQ09SRF9TRVBBUkFUT1IyID0gXCJcdTAwMWVcIjtcbnZhciBXb3JrZmxvdyA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgd29ya2Zsb3dJZCkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMud29ya2Zsb3dJZCA9IHdvcmtmbG93SWQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXN5bmMgZ2VuZXJhdG9yIHRoYXQgcHJvY2Vzc2VzIGEgcmVhZGFibGUgc3RyZWFtIGFuZCB5aWVsZHMgd29ya2Zsb3cgcmVjb3Jkc1xuICAgKiBzZXBhcmF0ZWQgYnkgdGhlIFJlY29yZCBTZXBhcmF0b3IgY2hhcmFjdGVyIChcXHgxRSlcbiAgICpcbiAgICogQHBhcmFtIHN0cmVhbSAtIFRoZSByZWFkYWJsZSBzdHJlYW0gdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyBBbiBhc3luYyBnZW5lcmF0b3IgdGhhdCB5aWVsZHMgcGFyc2VkIHJlY29yZHNcbiAgICovXG4gIGFzeW5jICpzdHJlYW1Qcm9jZXNzb3Ioc3RyZWFtKSB7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGxldCBkb25lUmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoIWRvbmVSZWFkaW5nKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGRvbmVSZWFkaW5nID0gZG9uZTtcbiAgICAgICAgaWYgKGRvbmUgJiYgIXZhbHVlKSBjb250aW51ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWNvZGVkID0gdmFsdWUgPyBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICBjb25zdCBjaHVua3MgPSAoYnVmZmVyICsgZGVjb2RlZCkuc3BsaXQoUkVDT1JEX1NFUEFSQVRPUjIpO1xuICAgICAgICAgIGJ1ZmZlciA9IGNodW5rcy5wb3AoKSB8fCBcIlwiO1xuICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRDaHVuayA9IEpTT04ucGFyc2UoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgeWllbGQgcGFyc2VkQ2h1bms7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2UoYnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGRldGFpbHMgYWJvdXQgdGhlIHdvcmtmbG93XG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB3b3JrZmxvdyBkZXRhaWxzIGluY2x1ZGluZyBzdGVwcyBhbmQgZ3JhcGhzXG4gICAqL1xuICBkZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzLyR7dGhpcy53b3JrZmxvd0lkfWApO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIHJ1bnMgZm9yIGEgd29ya2Zsb3dcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZyBydW5zXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB3b3JrZmxvdyBydW5zIGFycmF5XG4gICAqL1xuICBydW5zKHBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAocGFyYW1zPy5mcm9tRGF0ZSkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcImZyb21EYXRlXCIsIHBhcmFtcy5mcm9tRGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcz8udG9EYXRlKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwidG9EYXRlXCIsIHBhcmFtcy50b0RhdGUudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXM/LmxpbWl0KSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKHBhcmFtcy5saW1pdCkpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zPy5vZmZzZXQpIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKHBhcmFtcy5vZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcz8ucmVzb3VyY2VJZCkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcInJlc291cmNlSWRcIiwgcGFyYW1zLnJlc291cmNlSWQpO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoUGFyYW1zLnNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzLyR7dGhpcy53b3JrZmxvd0lkfS9ydW5zPyR7c2VhcmNoUGFyYW1zfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy8ke3RoaXMud29ya2Zsb3dJZH0vcnVuc2ApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB3b3JrZmxvdyBydW5cbiAgICogQHBhcmFtIHBhcmFtcyAtIE9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25hbCBydW5JZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHJ1bklkIG9mIHRoZSBjcmVhdGVkIHJ1blxuICAgKi9cbiAgY3JlYXRlUnVuKHBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoISFwYXJhbXM/LnJ1bklkKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwicnVuSWRcIiwgcGFyYW1zLnJ1bklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS93b3JrZmxvd3MvJHt0aGlzLndvcmtmbG93SWR9L2NyZWF0ZS1ydW4/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyBhIHdvcmtmbG93IHJ1biBzeW5jaHJvbm91c2x5IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHdvcmtmbG93IHRvIGNvbXBsZXRlXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBPYmplY3QgY29udGFpbmluZyB0aGUgcnVuSWQsIGlucHV0RGF0YSBhbmQgcnVudGltZUNvbnRleHRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZVxuICAgKi9cbiAgc3RhcnQocGFyYW1zKSB7XG4gICAgY29uc3QgcnVudGltZUNvbnRleHQgPSBwYXJzZUNsaWVudFJ1bnRpbWVDb250ZXh0KHBhcmFtcy5ydW50aW1lQ29udGV4dCk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS93b3JrZmxvd3MvJHt0aGlzLndvcmtmbG93SWR9L3N0YXJ0P3J1bklkPSR7cGFyYW1zLnJ1bklkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7IGlucHV0RGF0YTogcGFyYW1zPy5pbnB1dERhdGEsIHJ1bnRpbWVDb250ZXh0IH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyBhIHN1c3BlbmRlZCB3b3JrZmxvdyBzdGVwIHN5bmNocm9ub3VzbHkgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgd29ya2Zsb3cgdG8gY29tcGxldGVcbiAgICogQHBhcmFtIHBhcmFtcyAtIE9iamVjdCBjb250YWluaW5nIHRoZSBydW5JZCwgc3RlcCwgcmVzdW1lRGF0YSBhbmQgcnVudGltZUNvbnRleHRcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZVxuICAgKi9cbiAgcmVzdW1lKHtcbiAgICBzdGVwLFxuICAgIHJ1bklkLFxuICAgIHJlc3VtZURhdGEsXG4gICAgLi4ucmVzdFxuICB9KSB7XG4gICAgY29uc3QgcnVudGltZUNvbnRleHQgPSBwYXJzZUNsaWVudFJ1bnRpbWVDb250ZXh0KHJlc3QucnVudGltZUNvbnRleHQpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvd29ya2Zsb3dzLyR7dGhpcy53b3JrZmxvd0lkfS9yZXN1bWU/cnVuSWQ9JHtydW5JZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgYm9keToge1xuICAgICAgICBzdGVwLFxuICAgICAgICByZXN1bWVEYXRhLFxuICAgICAgICBydW50aW1lQ29udGV4dFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgYSB3b3JrZmxvdyBydW4gYXN5bmNocm9ub3VzbHkgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgd29ya2Zsb3cgaXMgY29tcGxldGVcbiAgICogQHBhcmFtIHBhcmFtcyAtIE9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25hbCBydW5JZCwgaW5wdXREYXRhIGFuZCBydW50aW1lQ29udGV4dFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHdvcmtmbG93IGV4ZWN1dGlvbiByZXN1bHRzXG4gICAqL1xuICBzdGFydEFzeW5jKHBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoISFwYXJhbXM/LnJ1bklkKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwicnVuSWRcIiwgcGFyYW1zLnJ1bklkKTtcbiAgICB9XG4gICAgY29uc3QgcnVudGltZUNvbnRleHQgPSBwYXJzZUNsaWVudFJ1bnRpbWVDb250ZXh0KHBhcmFtcy5ydW50aW1lQ29udGV4dCk7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS93b3JrZmxvd3MvJHt0aGlzLndvcmtmbG93SWR9L3N0YXJ0LWFzeW5jPyR7c2VhcmNoUGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHsgaW5wdXREYXRhOiBwYXJhbXMuaW5wdXREYXRhLCBydW50aW1lQ29udGV4dCB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgYSBzdXNwZW5kZWQgd29ya2Zsb3cgc3RlcCBhc3luY2hyb25vdXNseSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSB3b3JrZmxvdyBpcyBjb21wbGV0ZVxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJ1bklkLCBzdGVwLCByZXN1bWVEYXRhIGFuZCBydW50aW1lQ29udGV4dFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHdvcmtmbG93IHJlc3VtZSByZXN1bHRzXG4gICAqL1xuICByZXN1bWVBc3luYyhwYXJhbXMpIHtcbiAgICBjb25zdCBydW50aW1lQ29udGV4dCA9IHBhcnNlQ2xpZW50UnVudGltZUNvbnRleHQocGFyYW1zLnJ1bnRpbWVDb250ZXh0KTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy8ke3RoaXMud29ya2Zsb3dJZH0vcmVzdW1lLWFzeW5jP3J1bklkPSR7cGFyYW1zLnJ1bklkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHN0ZXA6IHBhcmFtcy5zdGVwLFxuICAgICAgICByZXN1bWVEYXRhOiBwYXJhbXMucmVzdW1lRGF0YSxcbiAgICAgICAgcnVudGltZUNvbnRleHRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV2F0Y2hlcyB3b3JrZmxvdyB0cmFuc2l0aW9ucyBpbiByZWFsLXRpbWVcbiAgICogQHBhcmFtIHJ1bklkIC0gT3B0aW9uYWwgcnVuIElEIHRvIGZpbHRlciB0aGUgd2F0Y2ggc3RyZWFtXG4gICAqIEByZXR1cm5zIEFzeW5jR2VuZXJhdG9yIHRoYXQgeWllbGRzIHBhcnNlZCByZWNvcmRzIGZyb20gdGhlIHdvcmtmbG93IHdhdGNoIHN0cmVhbVxuICAgKi9cbiAgYXN5bmMgd2F0Y2goeyBydW5JZCB9LCBvblJlY29yZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0KGAvYXBpL3dvcmtmbG93cy8ke3RoaXMud29ya2Zsb3dJZH0vd2F0Y2g/cnVuSWQ9JHtydW5JZH1gLCB7XG4gICAgICBzdHJlYW06IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3YXRjaCB3b3JrZmxvdzogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCByZWNvcmQgb2YgdGhpcy5zdHJlYW1Qcm9jZXNzb3IocmVzcG9uc2UuYm9keSkpIHtcbiAgICAgIG9uUmVjb3JkKHJlY29yZCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcmVzb3VyY2VzL2EyYS50c1xudmFyIEEyQSA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgYWdlbnRJZCkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuYWdlbnRJZCA9IGFnZW50SWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYWdlbnQgY2FyZCB3aXRoIG1ldGFkYXRhIGFib3V0IHRoZSBhZ2VudFxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGFnZW50IGNhcmQgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIGdldENhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgLy53ZWxsLWtub3duLyR7dGhpcy5hZ2VudElkfS9hZ2VudC5qc29uYCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBhZ2VudCBhbmQgZ2V0IGEgcmVzcG9uc2VcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSB0YXNrXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdGFzayByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hMmEvJHt0aGlzLmFnZW50SWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbWV0aG9kOiBcInRhc2tzL3NlbmRcIixcbiAgICAgICAgcGFyYW1zXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgdGFzazogcmVzcG9uc2UucmVzdWx0IH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIGFuZCByZXN1bHQgb2YgYSB0YXNrXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBxdWVyeWluZyB0aGUgdGFza1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHRhc2sgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIGdldFRhc2socGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoYC9hMmEvJHt0aGlzLmFnZW50SWR9YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbWV0aG9kOiBcInRhc2tzL2dldFwiLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWwgYSBydW5uaW5nIHRhc2tcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgaWRlbnRpZnlpbmcgdGhlIHRhc2sgdG8gY2FuY2VsXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdGFzayByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgY2FuY2VsVGFzayhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYTJhLyR7dGhpcy5hZ2VudElkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG1ldGhvZDogXCJ0YXNrcy9jYW5jZWxcIixcbiAgICAgICAgcGFyYW1zXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIGFuZCBzdWJzY3JpYmUgdG8gc3RyZWFtaW5nIHVwZGF0ZXMgKG5vdCBmdWxseSBpbXBsZW1lbnRlZClcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSB0YXNrXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdGFzayByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgc2VuZEFuZFN1YnNjcmliZShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYTJhLyR7dGhpcy5hZ2VudElkfWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG1ldGhvZDogXCJ0YXNrcy9zZW5kU3Vic2NyaWJlXCIsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfSxcbiAgICAgIHN0cmVhbTogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzb3VyY2VzL21jcC10b29sLnRzXG52YXIgTUNQVG9vbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVJlc291cmNlIHtcbiAgc2VydmVySWQ7XG4gIHRvb2xJZDtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVySWQsIHRvb2xJZCkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICB0aGlzLnRvb2xJZCA9IHRvb2xJZDtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGRldGFpbHMgYWJvdXQgdGhpcyBzcGVjaWZpYyB0b29sIGZyb20gdGhlIE1DUCBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgdG9vbCdzIGluZm9ybWF0aW9uIChuYW1lLCBkZXNjcmlwdGlvbiwgc2NoZW1hKS5cbiAgICovXG4gIGRldGFpbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tY3AvJHt0aGlzLnNlcnZlcklkfS90b29scy8ke3RoaXMudG9vbElkfWApO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGlzIHNwZWNpZmljIHRvb2wgb24gdGhlIE1DUCBzZXJ2ZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0b29sIGV4ZWN1dGlvbiwgaW5jbHVkaW5nIGRhdGEvYXJncyBhbmQgb3B0aW9uYWwgcnVudGltZUNvbnRleHQuXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIHRoZSB0b29sIGV4ZWN1dGlvbi5cbiAgICovXG4gIGV4ZWN1dGUocGFyYW1zKSB7XG4gICAgY29uc3QgYm9keSA9IHt9O1xuICAgIGlmIChwYXJhbXMuZGF0YSAhPT0gdm9pZCAwKSBib2R5LmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICBpZiAocGFyYW1zLnJ1bnRpbWVDb250ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIGJvZHkucnVudGltZUNvbnRleHQgPSBwYXJhbXMucnVudGltZUNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvbWNwLyR7dGhpcy5zZXJ2ZXJJZH0vdG9vbHMvJHt0aGlzLnRvb2xJZH0vZXhlY3V0ZWAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwID8gYm9keSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTWFzdHJhQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBCYXNlUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgYXZhaWxhYmxlIGFnZW50c1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgbWFwIG9mIGFnZW50IElEcyB0byBhZ2VudCBkZXRhaWxzXG4gICAqL1xuICBnZXRBZ2VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvYWdlbnRzXCIpO1xuICB9XG4gIGFzeW5jIGdldEFHVUkoeyByZXNvdXJjZUlkIH0pIHtcbiAgICBjb25zdCBhZ2VudHMgPSBhd2FpdCB0aGlzLmdldEFnZW50cygpO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhhZ2VudHMpLnJlZHVjZShcbiAgICAgIChhY2MsIFthZ2VudElkXSkgPT4ge1xuICAgICAgICBjb25zdCBhZ2VudCA9IHRoaXMuZ2V0QWdlbnQoYWdlbnRJZCk7XG4gICAgICAgIGFjY1thZ2VudElkXSA9IG5ldyBBR1VJQWRhcHRlcih7XG4gICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICBhZ2VudCxcbiAgICAgICAgICByZXNvdXJjZUlkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBhZ2VudCBpbnN0YW5jZSBieSBJRFxuICAgKiBAcGFyYW0gYWdlbnRJZCAtIElEIG9mIHRoZSBhZ2VudCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBBZ2VudCBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0QWdlbnQoYWdlbnRJZCkge1xuICAgIHJldHVybiBuZXcgQWdlbnQodGhpcy5vcHRpb25zLCBhZ2VudElkKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIG1lbW9yeSB0aHJlYWRzIGZvciBhIHJlc291cmNlXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHJlc291cmNlIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBtZW1vcnkgdGhyZWFkc1xuICAgKi9cbiAgZ2V0TWVtb3J5VGhyZWFkcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL21lbW9yeS90aHJlYWRzP3Jlc291cmNlaWQ9JHtwYXJhbXMucmVzb3VyY2VJZH0mYWdlbnRJZD0ke3BhcmFtcy5hZ2VudElkfWApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG1lbW9yeSB0aHJlYWRcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBtZW1vcnkgdGhyZWFkXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgY3JlYXRlZCBtZW1vcnkgdGhyZWFkXG4gICAqL1xuICBjcmVhdGVNZW1vcnlUaHJlYWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tZW1vcnkvdGhyZWFkcz9hZ2VudElkPSR7cGFyYW1zLmFnZW50SWR9YCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBib2R5OiBwYXJhbXMgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBtZW1vcnkgdGhyZWFkIGluc3RhbmNlIGJ5IElEXG4gICAqIEBwYXJhbSB0aHJlYWRJZCAtIElEIG9mIHRoZSBtZW1vcnkgdGhyZWFkIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIE1lbW9yeVRocmVhZCBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0TWVtb3J5VGhyZWFkKHRocmVhZElkLCBhZ2VudElkKSB7XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlUaHJlYWQodGhpcy5vcHRpb25zLCB0aHJlYWRJZCwgYWdlbnRJZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmVzIG1lc3NhZ2VzIHRvIG1lbW9yeVxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBjb250YWluaW5nIG1lc3NhZ2VzIHRvIHNhdmVcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBzYXZlZCBtZXNzYWdlc1xuICAgKi9cbiAgc2F2ZU1lc3NhZ2VUb01lbW9yeShwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL21lbW9yeS9zYXZlLW1lc3NhZ2VzP2FnZW50SWQ9JHtwYXJhbXMuYWdlbnRJZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogcGFyYW1zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YXR1cyBvZiB0aGUgbWVtb3J5IHN5c3RlbVxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgbWVtb3J5IHN5c3RlbSBzdGF0dXNcbiAgICovXG4gIGdldE1lbW9yeVN0YXR1cyhhZ2VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tZW1vcnkvc3RhdHVzP2FnZW50SWQ9JHthZ2VudElkfWApO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIGF2YWlsYWJsZSB0b29sc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgbWFwIG9mIHRvb2wgSURzIHRvIHRvb2wgZGV0YWlsc1xuICAgKi9cbiAgZ2V0VG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvdG9vbHNcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0b29sIGluc3RhbmNlIGJ5IElEXG4gICAqIEBwYXJhbSB0b29sSWQgLSBJRCBvZiB0aGUgdG9vbCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBUb29sIGluc3RhbmNlXG4gICAqL1xuICBnZXRUb29sKHRvb2xJZCkge1xuICAgIHJldHVybiBuZXcgVG9vbCh0aGlzLm9wdGlvbnMsIHRvb2xJZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgYXZhaWxhYmxlIGxlZ2FjeSB3b3JrZmxvd3NcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIG1hcCBvZiBsZWdhY3kgd29ya2Zsb3cgSURzIHRvIGxlZ2FjeSB3b3JrZmxvdyBkZXRhaWxzXG4gICAqL1xuICBnZXRMZWdhY3lXb3JrZmxvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvd29ya2Zsb3dzL2xlZ2FjeVwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGxlZ2FjeSB3b3JrZmxvdyBpbnN0YW5jZSBieSBJRFxuICAgKiBAcGFyYW0gd29ya2Zsb3dJZCAtIElEIG9mIHRoZSBsZWdhY3kgd29ya2Zsb3cgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgTGVnYWN5IFdvcmtmbG93IGluc3RhbmNlXG4gICAqL1xuICBnZXRMZWdhY3lXb3JrZmxvdyh3b3JrZmxvd0lkKSB7XG4gICAgcmV0dXJuIG5ldyBMZWdhY3lXb3JrZmxvdyh0aGlzLm9wdGlvbnMsIHdvcmtmbG93SWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIGF2YWlsYWJsZSB3b3JrZmxvd3NcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIG1hcCBvZiB3b3JrZmxvdyBJRHMgdG8gd29ya2Zsb3cgZGV0YWlsc1xuICAgKi9cbiAgZ2V0V29ya2Zsb3dzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoXCIvYXBpL3dvcmtmbG93c1wiKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHdvcmtmbG93IGluc3RhbmNlIGJ5IElEXG4gICAqIEBwYXJhbSB3b3JrZmxvd0lkIC0gSUQgb2YgdGhlIHdvcmtmbG93IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIFdvcmtmbG93IGluc3RhbmNlXG4gICAqL1xuICBnZXRXb3JrZmxvdyh3b3JrZmxvd0lkKSB7XG4gICAgcmV0dXJuIG5ldyBXb3JrZmxvdyh0aGlzLm9wdGlvbnMsIHdvcmtmbG93SWQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdmVjdG9yIGluc3RhbmNlIGJ5IG5hbWVcbiAgICogQHBhcmFtIHZlY3Rvck5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgVmVjdG9yIGluc3RhbmNlXG4gICAqL1xuICBnZXRWZWN0b3IodmVjdG9yTmFtZSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMub3B0aW9ucywgdmVjdG9yTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsb2dzXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBmaWx0ZXJpbmcgbG9nc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgbG9nIG1lc3NhZ2VzXG4gICAqL1xuICBnZXRMb2dzKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvbG9ncz90cmFuc3BvcnRJZD0ke3BhcmFtcy50cmFuc3BvcnRJZH1gKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBsb2dzIGZvciBhIHNwZWNpZmljIHJ1blxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBjb250YWluaW5nIHJ1biBJRCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgbG9nIG1lc3NhZ2VzXG4gICAqL1xuICBnZXRMb2dGb3JSdW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9sb2dzLyR7cGFyYW1zLnJ1bklkfT90cmFuc3BvcnRJZD0ke3BhcmFtcy50cmFuc3BvcnRJZH1gKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgbG9nIHRyYW5zcG9ydHNcbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGxpc3Qgb2YgbG9nIHRyYW5zcG9ydHNcbiAgICovXG4gIGdldExvZ1RyYW5zcG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChcIi9hcGkvbG9ncy90cmFuc3BvcnRzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCB0cmFjZXMgKHBhZ2VkKVxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgZmlsdGVyaW5nIHRyYWNlc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGVsZW1ldHJ5IGRhdGFcbiAgICovXG4gIGdldFRlbGVtZXRyeShwYXJhbXMpIHtcbiAgICBjb25zdCB7IG5hbWUsIHNjb3BlLCBwYWdlLCBwZXJQYWdlLCBhdHRyaWJ1dGUsIGZyb21EYXRlLCB0b0RhdGUgfSA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBfYXR0cmlidXRlID0gYXR0cmlidXRlID8gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke3ZhbHVlfWApIDogW107XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwic2NvcGVcIiwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAocGFnZSkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcInBhZ2VcIiwgU3RyaW5nKHBhZ2UpKTtcbiAgICB9XG4gICAgaWYgKHBlclBhZ2UpIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJwZXJQYWdlXCIsIFN0cmluZyhwZXJQYWdlKSk7XG4gICAgfVxuICAgIGlmIChfYXR0cmlidXRlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfYXR0cmlidXRlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgX2F0dHJpYnV0ZSkge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJhdHRyaWJ1dGVcIiwgYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJhdHRyaWJ1dGVcIiwgX2F0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcm9tRGF0ZSkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcImZyb21EYXRlXCIsIGZyb21EYXRlLnRvSVNPU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodG9EYXRlKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwidG9EYXRlXCIsIHRvRGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHNlYXJjaFBhcmFtcy5zaXplKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL3RlbGVtZXRyeT8ke3NlYXJjaFBhcmFtc31gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS90ZWxlbWV0cnlgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgYXZhaWxhYmxlIG5ldHdvcmtzXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBtYXAgb2YgbmV0d29yayBJRHMgdG8gbmV0d29yayBkZXRhaWxzXG4gICAqL1xuICBnZXROZXR3b3JrcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFwiL2FwaS9uZXR3b3Jrc1wiKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIG5ldHdvcmsgaW5zdGFuY2UgYnkgSURcbiAgICogQHBhcmFtIG5ldHdvcmtJZCAtIElEIG9mIHRoZSBuZXR3b3JrIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIE5ldHdvcmsgaW5zdGFuY2VcbiAgICovXG4gIGdldE5ldHdvcmsobmV0d29ya0lkKSB7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrKHRoaXMub3B0aW9ucywgbmV0d29ya0lkKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhdmFpbGFibGUgTUNQIHNlcnZlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBwYWdpbmF0aW9uIChsaW1pdCwgb2Zmc2V0KS5cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBsaXN0IG9mIE1DUCBzZXJ2ZXJzIGFuZCBwYWdpbmF0aW9uIGluZm8uXG4gICAqL1xuICBnZXRNY3BTZXJ2ZXJzKHBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAocGFyYW1zPy5saW1pdCAhPT0gdm9pZCAwKSB7XG4gICAgICBzZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKHBhcmFtcy5saW1pdCkpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zPy5vZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgc2VhcmNoUGFyYW1zLnNldChcIm9mZnNldFwiLCBTdHJpbmcocGFyYW1zLm9mZnNldCkpO1xuICAgIH1cbiAgICBjb25zdCBxdWVyeVN0cmluZyA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYC9hcGkvbWNwL3YwL3NlcnZlcnMke3F1ZXJ5U3RyaW5nID8gYD8ke3F1ZXJ5U3RyaW5nfWAgOiBcIlwifWApO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgZGV0YWlsZWQgaW5mb3JtYXRpb24gZm9yIGEgc3BlY2lmaWMgTUNQIHNlcnZlci5cbiAgICogQHBhcmFtIHNlcnZlcklkIC0gVGhlIElEIG9mIHRoZSBNQ1Agc2VydmVyIHRvIHJldHJpZXZlLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgZS5nLiwgc3BlY2lmaWMgdmVyc2lvbi5cbiAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBkZXRhaWxlZCBNQ1Agc2VydmVyIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZ2V0TWNwU2VydmVyRGV0YWlscyhzZXJ2ZXJJZCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGlmIChwYXJhbXM/LnZlcnNpb24pIHtcbiAgICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIHBhcmFtcy52ZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAvYXBpL21jcC92MC9zZXJ2ZXJzLyR7c2VydmVySWR9JHtxdWVyeVN0cmluZyA/IGA/JHtxdWVyeVN0cmluZ31gIDogXCJcIn1gKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGlzdCBvZiB0b29scyBmb3IgYSBzcGVjaWZpYyBNQ1Agc2VydmVyLlxuICAgKiBAcGFyYW0gc2VydmVySWQgLSBUaGUgSUQgb2YgdGhlIE1DUCBzZXJ2ZXIuXG4gICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgbGlzdCBvZiB0b29scy5cbiAgICovXG4gIGdldE1jcFNlcnZlclRvb2xzKHNlcnZlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChgL2FwaS9tY3AvJHtzZXJ2ZXJJZH0vdG9vbHNgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBNQ1BUb29sIHJlc291cmNlIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIHRvb2wgb24gYW4gTUNQIHNlcnZlci5cbiAgICogVGhpcyBpbnN0YW5jZSBjYW4gdGhlbiBiZSB1c2VkIHRvIGZldGNoIGRldGFpbHMgb3IgZXhlY3V0ZSB0aGUgdG9vbC5cbiAgICogQHBhcmFtIHNlcnZlcklkIC0gVGhlIElEIG9mIHRoZSBNQ1Agc2VydmVyLlxuICAgKiBAcGFyYW0gdG9vbElkIC0gVGhlIElEIG9mIHRoZSB0b29sLlxuICAgKiBAcmV0dXJucyBNQ1BUb29sIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0TWNwU2VydmVyVG9vbChzZXJ2ZXJJZCwgdG9vbElkKSB7XG4gICAgcmV0dXJuIG5ldyBNQ1BUb29sKHRoaXMub3B0aW9ucywgc2VydmVySWQsIHRvb2xJZCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gQTJBIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbiBhZ2VudCB2aWEgdGhlIEEyQSBwcm90b2NvbFxuICAgKiBAcGFyYW0gYWdlbnRJZCAtIElEIG9mIHRoZSBhZ2VudCB0byBpbnRlcmFjdCB3aXRoXG4gICAqIEByZXR1cm5zIEEyQSBjbGllbnQgaW5zdGFuY2VcbiAgICovXG4gIGdldEEyQShhZ2VudElkKSB7XG4gICAgcmV0dXJuIG5ldyBBMkEodGhpcy5vcHRpb25zLCBhZ2VudElkKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgTWFzdHJhQ2xpZW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mastra/client-js/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuntimeContext: () => (/* binding */ RuntimeContext)\n/* harmony export */ });\n// src/runtime-context/index.ts\nvar RuntimeContext = class {\n  registry = /* @__PURE__ */ new Map();\n  constructor(iterable) {\n    this.registry = new Map(iterable);\n  }\n  /**\n   * set a value with strict typing if `Values` is a Record and the key exists in it.\n   */\n  set(key, value) {\n    this.registry.set(key, value);\n  }\n  /**\n   * Get a value with its type\n   */\n  get(key) {\n    return this.registry.get(key);\n  }\n  /**\n   * Check if a key exists in the container\n   */\n  has(key) {\n    return this.registry.has(key);\n  }\n  /**\n   * Delete a value by key\n   */\n  delete(key) {\n    return this.registry.delete(key);\n  }\n  /**\n   * Clear all values from the container\n   */\n  clear() {\n    this.registry.clear();\n  }\n  /**\n   * Get all keys in the container\n   */\n  keys() {\n    return this.registry.keys();\n  }\n  /**\n   * Get all values in the container\n   */\n  values() {\n    return this.registry.values();\n  }\n  /**\n   * Get all entries in the container\n   */\n  entries() {\n    return this.registry.entries();\n  }\n  /**\n   * Get the size of the container\n   */\n  size() {\n    return this.registry.size;\n  }\n  /**\n   * Execute a function for each entry in the container\n   */\n  forEach(callbackfn) {\n    this.registry.forEach(callbackfn);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1hc3RyYS9jb3JlL2Rpc3QvY2h1bmstU0dHUEpXUlEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsiL2hvbWUvbXRhaGFzeWxtei9EZXNrdG9wL3Vwc3Rhc2gvbWFzdHJhL3dpdGhBcGkvbm9kZV9tb2R1bGVzL0BtYXN0cmEvY29yZS9kaXN0L2NodW5rLVNHR1BKV1JRLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ydW50aW1lLWNvbnRleHQvaW5kZXgudHNcbnZhciBSdW50aW1lQ29udGV4dCA9IGNsYXNzIHtcbiAgcmVnaXN0cnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihpdGVyYWJsZSkge1xuICAgIHRoaXMucmVnaXN0cnkgPSBuZXcgTWFwKGl0ZXJhYmxlKTtcbiAgfVxuICAvKipcbiAgICogc2V0IGEgdmFsdWUgd2l0aCBzdHJpY3QgdHlwaW5nIGlmIGBWYWx1ZXNgIGlzIGEgUmVjb3JkIGFuZCB0aGUga2V5IGV4aXN0cyBpbiBpdC5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5yZWdpc3RyeS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIHdpdGggaXRzIHR5cGVcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5nZXQoa2V5KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBrZXkgZXhpc3RzIGluIHRoZSBjb250YWluZXJcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5oYXMoa2V5KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgdmFsdWUgYnkga2V5XG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZGVsZXRlKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFsbCB2YWx1ZXMgZnJvbSB0aGUgY29udGFpbmVyXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5LmNsZWFyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBpbiB0aGUgY29udGFpbmVyXG4gICAqL1xuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCB2YWx1ZXMgaW4gdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnZhbHVlcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGVudHJpZXMgaW4gdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5lbnRyaWVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyXG4gICAqL1xuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgY29udGFpbmVyXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICB0aGlzLnJlZ2lzdHJ5LmZvckVhY2goY2FsbGJhY2tmbik7XG4gIH1cbn07XG5cbmV4cG9ydCB7IFJ1bnRpbWVDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mastra/core/dist/chunk-SGGPJWRQ.js\n");

/***/ })

};
;